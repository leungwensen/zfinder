{"version":3,"sources":["webpack:///webpack/universalModuleDefinition?5ca6","webpack:///dist/index-with-deps.min.js","webpack:///webpack/bootstrap 3113d29c60dbb1c7716a?9a86","webpack:///./src/index.js?9552","webpack:///./src/api/prop.js?e432","webpack:///./src/util/assign.js?d345","webpack:///./src/util/empty.js?09c2","webpack:///./src/api/symbols.js?660b","webpack:///./src/util/symbols.js?a96b","webpack:///./src/api/vdom.js?4eb1","webpack:///./~/incremental-dom/dist/incremental-dom-cjs.js?18a5","webpack:///./src/util/support.js?38e1","webpack:///./src/api/component.js?235b","webpack:///./src/util/data.js?2a96","webpack:///./src/util/debounce.js?6615","webpack:///./src/util/get-own-property-descriptors.js?e7ca","webpack:///./src/api/define.js?afad","webpack:///./src/lifecycle/render.js?6d98","webpack:///./src/api/props.js?3d18","webpack:///./src/util/dash-case.js?421e","webpack:///./src/lifecycle/props-init.js?f7e6","webpack:///./src/api/emit.js?fe68","webpack:///./src/api/link.js?74e6","webpack:///./src/api/ready.js?b83f"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","_interopRequireWildcard","newObj","key","Object","prototype","hasOwnProperty","defineProperty","value","vdom","symbols","ready","props","prop","link","emit","Component","undefined","_prop","_symbols","_vdom","_component","_component2","_define","_define2","_emit","_emit2","_link","_link2","_props","_props2","_ready","_ready2","create","def","_len","arguments","length","args","Array","_key","unshift","_assign2","apply","string","number","array","_assign","_empty","_empty2","alwaysUndefinedIfNotANumberOrNumber","val","isNaN","Number","alwaysUndefinedIfEmptyOrString","String","coerce","isArray","deserialize","JSON","parse","serialize","stringify","assign","bind","forEach","arg","keys","name","enumerable","get","shadowRoot","connected","created","ref","renderer","rendering","rendererDebounced","_toConsumableArray","arr","i","arr2","from","applyEvent","elem","ename","newFunc","events","__events","oldFunc","removeEventListener","addEventListener","resolveTagName","tname","fallbackToV0","wrapIdomFunc","func","tnameFuncHandler","wrap","stackChren","_incrementalDom","elementClose","eref","push","newAttr","stackProps","attr","stackOpen","statics","_len2","attrs","_key2","a","stackClose","chren","pop","stackVoid","element","atype","_typeof","newElementOpenStart","newElementOpenEnd","ctype","newText","newElementClose","text","elementVoid","elementOpenStart","elementOpenEnd","elementOpen","Symbol","iterator","constructor","_support","applyDefault","attributes","shadowDomV1","shadowDomV0","skip","checked","className","disabled","applyProp","indexOf","firstChar","eventName","substring","toUpperCase","toLowerCase","tagName","newElementOpen","newElementVoid","NodeData","nodeName","createMap","attrsArr","newAttrs","keyMap","keyMapValid","Context","notifications","nodesCreated","deleted","nodesDeleted","has","map","property","initData","node","data","getData","Element","getAttribute","placeholder","getNamespace","lastIndexOf","applyAttr","el","removeAttribute","attrNS","setAttributeNS","setAttribute","applyStyle","style","cssText","elStyle","applyAttributeTyped","type","updateAttribute","mutator","getNamespaceForTag","tag","parent","namespaceURI","createElement","doc","namespace","createElementNS","createText","createTextNode","createKeyMap","child","firstElementChild","nextElementSibling","getKeyMap","getChild","registerChild","markCreated","markDeleted","notifyChanges","context","currentNode","currentParent","patchFactory","run","f","fn","prevContext","prevRoot","prevDoc","prevCurrentNode","prevCurrentParent","ownerDocument","parentNode","patchInner","enterNode","exitNode","patchOuter","nextSibling","matches","alignWithDOM","replaceChild","insertBefore","clearUnvisitedDOM","lastChild","removeChild","nextNode","firstChild","coreElementOpen","coreElementClose","coreText","currentElement","ATTRIBUTES_OFFSET","argsBuilder","const_args","attrsChanged","j","_attr","elementPlaceholder","formatted","patch","document","win","window","div","customElementsV0","registerElement","customElementsV1","customElements","createShadowRoot","attachShadow","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","writable","configurable","setPrototypeOf","__proto__","_createClass","defineProperties","target","descriptor","protoProps","staticProps","_data","_data2","_debounce","_debounce2","_getOwnPropertyDescriptors","_getOwnPropertyDescriptors2","_HTMLElement","_this","getPrototypeOf","createdCallback","ctor","attached","render","detached","oldValue","newValue","_constructor","attributeChanged","observedAttributes","propertyName","propData","syncingAttribute","propOpts","settingAttribute","_this2","elemData","readyCallbacks","Ctor","cb","attributeChangedCallback","connectedCallback","disconnectedCallback","definition","Base","_Base","opts","prot","prev","HTMLElement","__SKATE_DATA","called","setTimeout","getOwnPropertyNames","reduce","curr","getOwnPropertyDescriptor","ensurePropertyFunctions","names","descriptors","descriptorName","_propsInit2","ensurePropertyDefinitions","formatLinkedAttributes","attribute","linkedAttr","_dashCase2","createInitProps","generateUniqueName","registry","rand","replace","r","Math","random","v","toString","Error","uniqueName","extend","_render2","extends","_render","_dashCase","_propsInit","rendered","updated","shouldRender","sr","mode","set","newProps","str","split","one","two","idx","dash","getDefaultValue","getInitialValue","initial","createNativePropertyDefinition","attributeName","initialValue","shouldSyncAttribute","hasAttribute","internalValue","shouldRemoveAttribute","changeData","serializedValue","createCustomEvent","CustomEvent","e","createEvent","initCustomEvent","bubbles","cancelable","detail","dispatchEvent","Event","_defineProperty","getValue","localTarget","parts","firstPart","propName","_props4","_props3","done","info"],"mappings":"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","file":"dist/index-with-deps.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"skate\"] = factory();\n\telse\n\t\troot[\"skate\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"skate\"] = factory();\n\telse\n\t\troot[\"skate\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.vdom = exports.symbols = exports.ready = exports.props = exports.prop = exports.link = exports.emit = exports.define = exports.Component = undefined;\n\t\n\tvar _prop = __webpack_require__(1);\n\t\n\tvar prop = _interopRequireWildcard(_prop);\n\t\n\tvar _symbols = __webpack_require__(4);\n\t\n\tvar symbols = _interopRequireWildcard(_symbols);\n\t\n\tvar _vdom = __webpack_require__(6);\n\t\n\tvar vdom = _interopRequireWildcard(_vdom);\n\t\n\tvar _component = __webpack_require__(9);\n\t\n\tvar _component2 = _interopRequireDefault(_component);\n\t\n\tvar _define = __webpack_require__(13);\n\t\n\tvar _define2 = _interopRequireDefault(_define);\n\t\n\tvar _emit = __webpack_require__(18);\n\t\n\tvar _emit2 = _interopRequireDefault(_emit);\n\t\n\tvar _link = __webpack_require__(19);\n\t\n\tvar _link2 = _interopRequireDefault(_link);\n\t\n\tvar _props = __webpack_require__(15);\n\t\n\tvar _props2 = _interopRequireDefault(_props);\n\t\n\tvar _ready = __webpack_require__(20);\n\t\n\tvar _ready2 = _interopRequireDefault(_ready);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\texports.Component = _component2.default;\n\texports.define = _define2.default;\n\texports.emit = _emit2.default;\n\texports.link = _link2.default;\n\texports.prop = prop;\n\texports.props = _props2.default;\n\texports.ready = _ready2.default;\n\texports.symbols = symbols;\n\texports.vdom = vdom;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.string = exports.number = exports.boolean = exports.array = undefined;\n\texports.create = create;\n\t\n\tvar _assign = __webpack_require__(2);\n\t\n\tvar _assign2 = _interopRequireDefault(_assign);\n\t\n\tvar _empty = __webpack_require__(3);\n\t\n\tvar _empty2 = _interopRequireDefault(_empty);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar alwaysUndefinedIfNotANumberOrNumber = function alwaysUndefinedIfNotANumberOrNumber(val) {\n\t  return isNaN(val) ? undefined : Number(val);\n\t};\n\tvar alwaysUndefinedIfEmptyOrString = function alwaysUndefinedIfEmptyOrString(val) {\n\t  return (0, _empty2.default)(val) ? undefined : String(val);\n\t};\n\t\n\tfunction create(def) {\n\t  return function () {\n\t    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t      args[_key] = arguments[_key];\n\t    }\n\t\n\t    args.unshift({}, def);\n\t    return _assign2.default.apply(null, args);\n\t  };\n\t}\n\t\n\tvar array = exports.array = create({\n\t  coerce: function coerce(val) {\n\t    return Array.isArray(val) ? val : [val];\n\t  },\n\t  default: function _default() {\n\t    return [];\n\t  },\n\t  deserialize: JSON.parse,\n\t  serialize: JSON.stringify\n\t});\n\t\n\tvar boolean = exports.boolean = create({\n\t  coerce: function coerce(value) {\n\t    return !!value;\n\t  },\n\t  default: false,\n\t  deserialize: function deserialize(value) {\n\t    return !(value === null);\n\t  },\n\t  serialize: function serialize(value) {\n\t    return value ? '' : undefined;\n\t  }\n\t});\n\t\n\tvar number = exports.number = create({\n\t  default: 0,\n\t  coerce: alwaysUndefinedIfNotANumberOrNumber,\n\t  deserialize: alwaysUndefinedIfNotANumberOrNumber,\n\t  serialize: alwaysUndefinedIfNotANumberOrNumber\n\t});\n\t\n\tvar string = exports.string = create({\n\t  default: '',\n\t  coerce: alwaysUndefinedIfEmptyOrString,\n\t  deserialize: alwaysUndefinedIfEmptyOrString,\n\t  serialize: alwaysUndefinedIfEmptyOrString\n\t});\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\tvar assign = Object.assign;\n\texports.default = assign ? assign.bind(Object) : function (obj) {\n\t  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t    args[_key - 1] = arguments[_key];\n\t  }\n\t\n\t  args.forEach(function (arg) {\n\t    return Object.keys(arg).forEach(function (name) {\n\t      return obj[name] = arg[name];\n\t    });\n\t  }); // eslint-disable-line no-return-assign\n\t  return obj;\n\t};\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\texports.default = function (val) {\n\t  return typeof val === 'undefined' || val === null;\n\t};\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _symbols = __webpack_require__(5);\n\t\n\tObject.defineProperty(exports, 'name', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _symbols.name;\n\t  }\n\t});\n\tObject.defineProperty(exports, 'shadowRoot', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _symbols.shadowRoot;\n\t  }\n\t});\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\tvar connected = exports.connected = '____skate_connected';\n\tvar created = exports.created = '____skate_created';\n\tvar name = exports.name = '____skate_name';\n\tvar props = exports.props = '____skate_props';\n\tvar ref = exports.ref = '____skate_ref';\n\tvar renderer = exports.renderer = '____skate_renderer';\n\tvar rendering = exports.rendering = '____skate_rendering';\n\tvar rendererDebounced = exports.rendererDebounced = '____skate_rendererDebounced';\n\tvar shadowRoot = exports.shadowRoot = '____skate_shadowRoot';\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.text = exports.elementVoid = exports.elementOpenStart = exports.elementOpenEnd = exports.elementOpen = exports.elementClose = exports.attr = undefined;\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\t\n\texports.element = element;\n\t\n\tvar _incrementalDom = __webpack_require__(7);\n\t\n\tvar _symbols = __webpack_require__(5);\n\t\n\tvar _support = __webpack_require__(8);\n\t\n\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\t\n\tvar applyDefault = _incrementalDom.attributes[_incrementalDom.symbols.default];\n\tvar fallbackToV0 = !_support.shadowDomV1 && _support.shadowDomV0;\n\tvar stackChren = [];\n\tvar stackProps = [];\n\t\n\t// Adds or removes an event listener for an element.\n\tfunction applyEvent(elem, ename, newFunc) {\n\t  var events = elem.__events;\n\t\n\t  if (!events) {\n\t    events = elem.__events = {};\n\t  }\n\t\n\t  var oldFunc = events[ename];\n\t\n\t  // Remove old listener so they don't double up.\n\t  if (oldFunc) {\n\t    elem.removeEventListener(ename, oldFunc);\n\t  }\n\t\n\t  // Bind new listener.\n\t  if (newFunc) {\n\t    elem.addEventListener(ename, events[ename] = newFunc);\n\t  }\n\t}\n\t\n\t// Attributes that are not handled by Incremental DOM.\n\t_incrementalDom.attributes.key = _incrementalDom.attributes.skip = _incrementalDom.attributes.statics = function () {};\n\t\n\t// Attributes that *must* be set via a property on all elements.\n\t_incrementalDom.attributes.checked = _incrementalDom.attributes.className = _incrementalDom.attributes.disabled = _incrementalDom.attributes.value = _incrementalDom.applyProp;\n\t\n\t// Default attribute applicator.\n\t_incrementalDom.attributes[_incrementalDom.symbols.default] = function (elem, name, value) {\n\t  // If the skip attribute was specified, skip\n\t  if (name === 'skip' && value) {\n\t    return (0, _incrementalDom.skip)();\n\t  }\n\t\n\t  // Add the ref to the element so it can be called when it's closed.\n\t  if (name === 'ref') {\n\t    elem[_symbols.ref] = value;\n\t    return;\n\t  }\n\t\n\t  // Custom element properties should be set as properties.\n\t  var props = elem.constructor.props;\n\t  if (props && name in props) {\n\t    return (0, _incrementalDom.applyProp)(elem, name, value);\n\t  }\n\t\n\t  // Boolean false values should not set attributes at all.\n\t  if (value === false) {\n\t    return;\n\t  }\n\t\n\t  // Handle built-in and custom events.\n\t  if (name.indexOf('on') === 0) {\n\t    var firstChar = name[2];\n\t    var eventName = void 0;\n\t\n\t    if (firstChar === '-') {\n\t      eventName = name.substring(3);\n\t    } else if (firstChar === firstChar.toUpperCase()) {\n\t      eventName = firstChar.toLowerCase() + name.substring(3);\n\t    }\n\t\n\t    if (eventName) {\n\t      applyEvent(elem, eventName, value);\n\t      return;\n\t    }\n\t  }\n\t\n\t  // Set the select attribute instead of name if it was a <slot> translated to\n\t  // a <content> for v0.\n\t  if (name === 'name' && elem.tagName === 'CONTENT') {\n\t    name = 'select';\n\t    value = '[slot=\"' + value + '\"]';\n\t  }\n\t\n\t  // Set defined props on the element directly.\n\t  if (name in elem) {\n\t    (0, _incrementalDom.applyProp)(elem, name, value);\n\t    return;\n\t  }\n\t\n\t  // Fallback to default IncrementalDOM behaviour.\n\t  applyDefault(elem, name, value);\n\t};\n\t\n\tfunction resolveTagName(tname) {\n\t  // If the tag name is a function, a Skate constructor or a standard function\n\t  // is supported.\n\t  //\n\t  // - If a Skate constructor, the tag name is extracted from that.\n\t  // - If a standard function, it is used as a helper.\n\t  if (typeof tname === 'function') {\n\t    return tname[_symbols.name] || tname;\n\t  }\n\t\n\t  // Skate allows the consumer to use <slot /> and it will translate it to\n\t  // <content /> if Shadow DOM V0 is preferred.\n\t  if (tname === 'slot' && fallbackToV0) {\n\t    return 'content';\n\t  }\n\t\n\t  // All other tag names are just passed through.\n\t  return tname;\n\t}\n\t\n\tfunction wrapIdomFunc(func) {\n\t  var tnameFuncHandler = arguments.length <= 1 || arguments[1] === undefined ? function () {} : arguments[1];\n\t\n\t  return function wrap() {\n\t    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t      args[_key] = arguments[_key];\n\t    }\n\t\n\t    args[0] = resolveTagName(args[0]);\n\t    if (typeof args[0] === 'function') {\n\t      // If we've encountered a function, handle it according to the type of\n\t      // function that is being wrapped.\n\t      return tnameFuncHandler.apply(undefined, args);\n\t    } else if (stackChren.length) {\n\t      // We pass the wrap() function in here so that when it's called as\n\t      // children, it will queue up for the next stack, if there is one.\n\t      stackChren[stackChren.length - 1].push([wrap, args]);\n\t    } else {\n\t      // If there is no stack left, we call Incremental DOM directly.\n\t      var elem = func.apply(undefined, args);\n\t\n\t      // If we're in elementClose, try calling the ref.\n\t      if (func === _incrementalDom.elementClose) {\n\t        var eref = elem[_symbols.ref];\n\t        if (typeof eref === 'function') {\n\t          eref(elem);\n\t        }\n\t      }\n\t\n\t      return elem;\n\t    }\n\t  };\n\t}\n\t\n\tfunction newAttr(key, val) {\n\t  if (stackProps.length) {\n\t    stackProps[stackProps.length - 1][key] = val;\n\t  } else {\n\t    return (0, _incrementalDom.attr)(key, val);\n\t  }\n\t}\n\t\n\tfunction stackOpen(tname, key, statics) {\n\t  var props = { key: key, statics: statics };\n\t\n\t  for (var _len2 = arguments.length, attrs = Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n\t    attrs[_key2 - 3] = arguments[_key2];\n\t  }\n\t\n\t  for (var a = 0; a < attrs.length; a += 2) {\n\t    props[attrs[a]] = attrs[a + 1];\n\t  }\n\t  stackChren.push([]);\n\t  stackProps.push(props);\n\t}\n\t\n\tfunction stackClose(tname) {\n\t  var chren = stackChren.pop();\n\t  var props = stackProps.pop();\n\t  return tname(props, function () {\n\t    return chren.forEach(function (args) {\n\t      return args[0].apply(args, _toConsumableArray(args[1]));\n\t    });\n\t  });\n\t}\n\t\n\tfunction stackVoid() {\n\t  stackOpen.apply(undefined, arguments);\n\t  return stackClose(arguments.length <= 0 ? undefined : arguments[0]);\n\t}\n\t\n\t// Patch element factories.\n\tvar newElementClose = wrapIdomFunc(_incrementalDom.elementClose, stackClose);\n\tvar newElementOpen = wrapIdomFunc(_incrementalDom.elementOpen, stackOpen);\n\tvar newElementOpenEnd = wrapIdomFunc(_incrementalDom.elementOpenEnd);\n\tvar newElementOpenStart = wrapIdomFunc(_incrementalDom.elementOpenStart, stackOpen);\n\tvar newElementVoid = wrapIdomFunc(_incrementalDom.elementVoid, stackVoid);\n\tvar newText = wrapIdomFunc(_incrementalDom.text);\n\t\n\t// Convenience function for declaring an Incremental DOM element using\n\t// hyperscript-style syntax.\n\tfunction element(tname, attrs, chren) {\n\t  var atype = typeof attrs === 'undefined' ? 'undefined' : _typeof(attrs);\n\t\n\t  // If attributes are a function, then they should be treated as children.\n\t  if (atype === 'function' || atype === 'string') {\n\t    chren = attrs;\n\t  }\n\t\n\t  // Ensure the attributes are an object.\n\t  if (atype !== 'object') {\n\t    attrs = {};\n\t  }\n\t\n\t  // We open the element so we can set attrs after.\n\t  newElementOpenStart(tname, attrs.key, attrs.statics);\n\t\n\t  // Delete so special attrs don't actually get set.\n\t  delete attrs.key;\n\t  delete attrs.statics;\n\t\n\t  // Set attributes.\n\t  Object.keys(attrs).forEach(function (name) {\n\t    return newAttr(name, attrs[name]);\n\t  });\n\t\n\t  // Close before we render the descendant tree.\n\t  newElementOpenEnd(tname);\n\t\n\t  var ctype = typeof chren === 'undefined' ? 'undefined' : _typeof(chren);\n\t  if (ctype === 'function') {\n\t    chren();\n\t  } else if (ctype === 'string' || ctype === 'number') {\n\t    newText(chren);\n\t  }\n\t\n\t  return newElementClose(tname);\n\t}\n\t\n\t// We don't have to do anything special for the text function; it's just a\n\t// straight export from Incremental DOM.\n\texports.attr = newAttr;\n\texports.elementClose = newElementClose;\n\texports.elementOpen = newElementOpen;\n\texports.elementOpenEnd = newElementOpenEnd;\n\texports.elementOpenStart = newElementOpenStart;\n\texports.elementVoid = newElementVoid;\n\texports.text = newText;\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t * @license\n\t * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *      http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS-IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t\n\t'use strict';\n\t\n\t/**\n\t * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *      http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS-IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t\n\t/**\n\t * A cached reference to the hasOwnProperty function.\n\t */\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\t\n\tvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\t\n\t/**\n\t * A cached reference to the create function.\n\t */\n\tvar create = Object.create;\n\t\n\t/**\n\t * Used to prevent property collisions between our \"map\" and its prototype.\n\t * @param {!Object<string, *>} map The map to check.\n\t * @param {string} property The property to check.\n\t * @return {boolean} Whether map has property.\n\t */\n\tvar has = function has(map, property) {\n\t  return hasOwnProperty.call(map, property);\n\t};\n\t\n\t/**\n\t * Creates an map object without a prototype.\n\t * @return {!Object}\n\t */\n\tvar createMap = function createMap() {\n\t  return create(null);\n\t};\n\t\n\t/**\n\t * Keeps track of information needed to perform diffs for a given DOM node.\n\t * @param {!string} nodeName\n\t * @param {?string=} key\n\t * @constructor\n\t */\n\tfunction NodeData(nodeName, key) {\n\t  /**\n\t   * The attributes and their values.\n\t   * @const {!Object<string, *>}\n\t   */\n\t  this.attrs = createMap();\n\t\n\t  /**\n\t   * An array of attribute name/value pairs, used for quickly diffing the\n\t   * incomming attributes to see if the DOM node's attributes need to be\n\t   * updated.\n\t   * @const {Array<*>}\n\t   */\n\t  this.attrsArr = [];\n\t\n\t  /**\n\t   * The incoming attributes for this Node, before they are updated.\n\t   * @const {!Object<string, *>}\n\t   */\n\t  this.newAttrs = createMap();\n\t\n\t  /**\n\t   * The key used to identify this node, used to preserve DOM nodes when they\n\t   * move within their parent.\n\t   * @const\n\t   */\n\t  this.key = key;\n\t\n\t  /**\n\t   * Keeps track of children within this node by their key.\n\t   * {?Object<string, !Element>}\n\t   */\n\t  this.keyMap = null;\n\t\n\t  /**\n\t   * Whether or not the keyMap is currently valid.\n\t   * {boolean}\n\t   */\n\t  this.keyMapValid = true;\n\t\n\t  /**\n\t   * The node name for this node.\n\t   * @const {string}\n\t   */\n\t  this.nodeName = nodeName;\n\t\n\t  /**\n\t   * @type {?string}\n\t   */\n\t  this.text = null;\n\t}\n\t\n\t/**\n\t * Initializes a NodeData object for a Node.\n\t *\n\t * @param {Node} node The node to initialize data for.\n\t * @param {string} nodeName The node name of node.\n\t * @param {?string=} key The key that identifies the node.\n\t * @return {!NodeData} The newly initialized data object\n\t */\n\tvar initData = function initData(node, nodeName, key) {\n\t  var data = new NodeData(nodeName, key);\n\t  node['__incrementalDOMData'] = data;\n\t  return data;\n\t};\n\t\n\t/**\n\t * Retrieves the NodeData object for a Node, creating it if necessary.\n\t *\n\t * @param {Node} node The node to retrieve the data for.\n\t * @return {!NodeData} The NodeData for this Node.\n\t */\n\tvar getData = function getData(node) {\n\t  var data = node['__incrementalDOMData'];\n\t\n\t  if (!data) {\n\t    var nodeName = node.nodeName.toLowerCase();\n\t    var key = null;\n\t\n\t    if (node instanceof Element) {\n\t      key = node.getAttribute('key');\n\t    }\n\t\n\t    data = initData(node, nodeName, key);\n\t  }\n\t\n\t  return data;\n\t};\n\t\n\t/**\n\t * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *      http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS-IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t\n\t/** @const */\n\tvar symbols = {\n\t  default: '__default',\n\t\n\t  placeholder: '__placeholder'\n\t};\n\t\n\t/**\n\t * @param {string} name\n\t * @return {string|undefined} The namespace to use for the attribute.\n\t */\n\tvar getNamespace = function getNamespace(name) {\n\t  if (name.lastIndexOf('xml:', 0) === 0) {\n\t    return 'http://www.w3.org/XML/1998/namespace';\n\t  }\n\t\n\t  if (name.lastIndexOf('xlink:', 0) === 0) {\n\t    return 'http://www.w3.org/1999/xlink';\n\t  }\n\t};\n\t\n\t/**\n\t * Applies an attribute or property to a given Element. If the value is null\n\t * or undefined, it is removed from the Element. Otherwise, the value is set\n\t * as an attribute.\n\t * @param {!Element} el\n\t * @param {string} name The attribute's name.\n\t * @param {?(boolean|number|string)=} value The attribute's value.\n\t */\n\tvar applyAttr = function applyAttr(el, name, value) {\n\t  if (value == null) {\n\t    el.removeAttribute(name);\n\t  } else {\n\t    var attrNS = getNamespace(name);\n\t    if (attrNS) {\n\t      el.setAttributeNS(attrNS, name, value);\n\t    } else {\n\t      el.setAttribute(name, value);\n\t    }\n\t  }\n\t};\n\t\n\t/**\n\t * Applies a property to a given Element.\n\t * @param {!Element} el\n\t * @param {string} name The property's name.\n\t * @param {*} value The property's value.\n\t */\n\tvar applyProp = function applyProp(el, name, value) {\n\t  el[name] = value;\n\t};\n\t\n\t/**\n\t * Applies a style to an Element. No vendor prefix expansion is done for\n\t * property names/values.\n\t * @param {!Element} el\n\t * @param {string} name The attribute's name.\n\t * @param {*} style The style to set. Either a string of css or an object\n\t *     containing property-value pairs.\n\t */\n\tvar applyStyle = function applyStyle(el, name, style) {\n\t  if (typeof style === 'string') {\n\t    el.style.cssText = style;\n\t  } else {\n\t    el.style.cssText = '';\n\t    var elStyle = el.style;\n\t    var obj = /** @type {!Object<string,string>} */style;\n\t\n\t    for (var prop in obj) {\n\t      if (has(obj, prop)) {\n\t        elStyle[prop] = obj[prop];\n\t      }\n\t    }\n\t  }\n\t};\n\t\n\t/**\n\t * Updates a single attribute on an Element.\n\t * @param {!Element} el\n\t * @param {string} name The attribute's name.\n\t * @param {*} value The attribute's value. If the value is an object or\n\t *     function it is set on the Element, otherwise, it is set as an HTML\n\t *     attribute.\n\t */\n\tvar applyAttributeTyped = function applyAttributeTyped(el, name, value) {\n\t  var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);\n\t\n\t  if (type === 'object' || type === 'function') {\n\t    applyProp(el, name, value);\n\t  } else {\n\t    applyAttr(el, name, /** @type {?(boolean|number|string)} */value);\n\t  }\n\t};\n\t\n\t/**\n\t * Calls the appropriate attribute mutator for this attribute.\n\t * @param {!Element} el\n\t * @param {string} name The attribute's name.\n\t * @param {*} value The attribute's value.\n\t */\n\tvar updateAttribute = function updateAttribute(el, name, value) {\n\t  var data = getData(el);\n\t  var attrs = data.attrs;\n\t\n\t  if (attrs[name] === value) {\n\t    return;\n\t  }\n\t\n\t  var mutator = attributes[name] || attributes[symbols.default];\n\t  mutator(el, name, value);\n\t\n\t  attrs[name] = value;\n\t};\n\t\n\t/**\n\t * A publicly mutable object to provide custom mutators for attributes.\n\t * @const {!Object<string, function(!Element, string, *)>}\n\t */\n\tvar attributes = createMap();\n\t\n\t// Special generic mutator that's called for any attribute that does not\n\t// have a specific mutator.\n\tattributes[symbols.default] = applyAttributeTyped;\n\t\n\tattributes[symbols.placeholder] = function () {};\n\t\n\tattributes['style'] = applyStyle;\n\t\n\t/**\n\t * Gets the namespace to create an element (of a given tag) in.\n\t * @param {string} tag The tag to get the namespace for.\n\t * @param {?Node} parent\n\t * @return {?string} The namespace to create the tag in.\n\t */\n\tvar getNamespaceForTag = function getNamespaceForTag(tag, parent) {\n\t  if (tag === 'svg') {\n\t    return 'http://www.w3.org/2000/svg';\n\t  }\n\t\n\t  if (getData(parent).nodeName === 'foreignObject') {\n\t    return null;\n\t  }\n\t\n\t  return parent.namespaceURI;\n\t};\n\t\n\t/**\n\t * Creates an Element.\n\t * @param {Document} doc The document with which to create the Element.\n\t * @param {?Node} parent\n\t * @param {string} tag The tag for the Element.\n\t * @param {?string=} key A key to identify the Element.\n\t * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n\t *     static attributes for the Element.\n\t * @return {!Element}\n\t */\n\tvar createElement = function createElement(doc, parent, tag, key, statics) {\n\t  var namespace = getNamespaceForTag(tag, parent);\n\t  var el = undefined;\n\t\n\t  if (namespace) {\n\t    el = doc.createElementNS(namespace, tag);\n\t  } else {\n\t    el = doc.createElement(tag);\n\t  }\n\t\n\t  initData(el, tag, key);\n\t\n\t  if (statics) {\n\t    for (var i = 0; i < statics.length; i += 2) {\n\t      updateAttribute(el, /** @type {!string}*/statics[i], statics[i + 1]);\n\t    }\n\t  }\n\t\n\t  return el;\n\t};\n\t\n\t/**\n\t * Creates a Text Node.\n\t * @param {Document} doc The document with which to create the Element.\n\t * @return {!Text}\n\t */\n\tvar createText = function createText(doc) {\n\t  var node = doc.createTextNode('');\n\t  initData(node, '#text', null);\n\t  return node;\n\t};\n\t\n\t/**\n\t * Creates a mapping that can be used to look up children using a key.\n\t * @param {?Node} el\n\t * @return {!Object<string, !Element>} A mapping of keys to the children of the\n\t *     Element.\n\t */\n\tvar createKeyMap = function createKeyMap(el) {\n\t  var map = createMap();\n\t  var child = el.firstElementChild;\n\t\n\t  while (child) {\n\t    var key = getData(child).key;\n\t\n\t    if (key) {\n\t      map[key] = child;\n\t    }\n\t\n\t    child = child.nextElementSibling;\n\t  }\n\t\n\t  return map;\n\t};\n\t\n\t/**\n\t * Retrieves the mapping of key to child node for a given Element, creating it\n\t * if necessary.\n\t * @param {?Node} el\n\t * @return {!Object<string, !Node>} A mapping of keys to child Elements\n\t */\n\tvar getKeyMap = function getKeyMap(el) {\n\t  var data = getData(el);\n\t\n\t  if (!data.keyMap) {\n\t    data.keyMap = createKeyMap(el);\n\t  }\n\t\n\t  return data.keyMap;\n\t};\n\t\n\t/**\n\t * Retrieves a child from the parent with the given key.\n\t * @param {?Node} parent\n\t * @param {?string=} key\n\t * @return {?Node} The child corresponding to the key.\n\t */\n\tvar getChild = function getChild(parent, key) {\n\t  return key ? getKeyMap(parent)[key] : null;\n\t};\n\t\n\t/**\n\t * Registers an element as being a child. The parent will keep track of the\n\t * child using the key. The child can be retrieved using the same key using\n\t * getKeyMap. The provided key should be unique within the parent Element.\n\t * @param {?Node} parent The parent of child.\n\t * @param {string} key A key to identify the child with.\n\t * @param {!Node} child The child to register.\n\t */\n\tvar registerChild = function registerChild(parent, key, child) {\n\t  getKeyMap(parent)[key] = child;\n\t};\n\t\n\t/**\n\t * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *      http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS-IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t\n\t/** @const */\n\tvar notifications = {\n\t  /**\n\t   * Called after patch has compleated with any Nodes that have been created\n\t   * and added to the DOM.\n\t   * @type {?function(Array<!Node>)}\n\t   */\n\t  nodesCreated: null,\n\t\n\t  /**\n\t   * Called after patch has compleated with any Nodes that have been removed\n\t   * from the DOM.\n\t   * Note it's an applications responsibility to handle any childNodes.\n\t   * @type {?function(Array<!Node>)}\n\t   */\n\t  nodesDeleted: null\n\t};\n\t\n\t/**\n\t * Keeps track of the state of a patch.\n\t * @constructor\n\t */\n\tfunction Context() {\n\t  /**\n\t   * @type {(Array<!Node>|undefined)}\n\t   */\n\t  this.created = notifications.nodesCreated && [];\n\t\n\t  /**\n\t   * @type {(Array<!Node>|undefined)}\n\t   */\n\t  this.deleted = notifications.nodesDeleted && [];\n\t}\n\t\n\t/**\n\t * @param {!Node} node\n\t */\n\tContext.prototype.markCreated = function (node) {\n\t  if (this.created) {\n\t    this.created.push(node);\n\t  }\n\t};\n\t\n\t/**\n\t * @param {!Node} node\n\t */\n\tContext.prototype.markDeleted = function (node) {\n\t  if (this.deleted) {\n\t    this.deleted.push(node);\n\t  }\n\t};\n\t\n\t/**\n\t * Notifies about nodes that were created during the patch opearation.\n\t */\n\tContext.prototype.notifyChanges = function () {\n\t  if (this.created && this.created.length > 0) {\n\t    notifications.nodesCreated(this.created);\n\t  }\n\t\n\t  if (this.deleted && this.deleted.length > 0) {\n\t    notifications.nodesDeleted(this.deleted);\n\t  }\n\t};\n\t\n\t/**\n\t* Makes sure that keyed Element matches the tag name provided.\n\t* @param {!string} nodeName The nodeName of the node that is being matched.\n\t* @param {string=} tag The tag name of the Element.\n\t* @param {?string=} key The key of the Element.\n\t*/\n\tvar assertKeyedTagMatches = function assertKeyedTagMatches(nodeName, tag, key) {\n\t  if (nodeName !== tag) {\n\t    throw new Error('Was expecting node with key \"' + key + '\" to be a ' + tag + ', not a ' + nodeName + '.');\n\t  }\n\t};\n\t\n\t/** @type {?Context} */\n\tvar context = null;\n\t\n\t/** @type {?Node} */\n\tvar currentNode = null;\n\t\n\t/** @type {?Node} */\n\tvar currentParent = null;\n\t\n\t/** @type {?Element|?DocumentFragment} */\n\tvar root = null;\n\t\n\t/** @type {?Document} */\n\tvar doc = null;\n\t\n\t/**\n\t * Returns a patcher function that sets up and restores a patch context,\n\t * running the run function with the provided data.\n\t * @param {function((!Element|!DocumentFragment),!function(T),T=)} run\n\t * @return {function((!Element|!DocumentFragment),!function(T),T=)}\n\t * @template T\n\t */\n\tvar patchFactory = function patchFactory(run) {\n\t  /**\n\t   * TODO(moz): These annotations won't be necessary once we switch to Closure\n\t   * Compiler's new type inference. Remove these once the switch is done.\n\t   *\n\t   * @param {(!Element|!DocumentFragment)} node\n\t   * @param {!function(T)} fn\n\t   * @param {T=} data\n\t   * @template T\n\t   */\n\t  var f = function f(node, fn, data) {\n\t    var prevContext = context;\n\t    var prevRoot = root;\n\t    var prevDoc = doc;\n\t    var prevCurrentNode = currentNode;\n\t    var prevCurrentParent = currentParent;\n\t    var previousInAttributes = false;\n\t    var previousInSkip = false;\n\t\n\t    context = new Context();\n\t    root = node;\n\t    doc = node.ownerDocument;\n\t    currentParent = node.parentNode;\n\t\n\t    if (false) {}\n\t\n\t    run(node, fn, data);\n\t\n\t    if (false) {}\n\t\n\t    context.notifyChanges();\n\t\n\t    context = prevContext;\n\t    root = prevRoot;\n\t    doc = prevDoc;\n\t    currentNode = prevCurrentNode;\n\t    currentParent = prevCurrentParent;\n\t  };\n\t  return f;\n\t};\n\t\n\t/**\n\t * Patches the document starting at node with the provided function. This\n\t * function may be called during an existing patch operation.\n\t * @param {!Element|!DocumentFragment} node The Element or Document\n\t *     to patch.\n\t * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.\n\t *     calls that describe the DOM.\n\t * @param {T=} data An argument passed to fn to represent DOM state.\n\t * @template T\n\t */\n\tvar patchInner = patchFactory(function (node, fn, data) {\n\t  currentNode = node;\n\t\n\t  enterNode();\n\t  fn(data);\n\t  exitNode();\n\t\n\t  if (false) {}\n\t});\n\t\n\t/**\n\t * Patches an Element with the the provided function. Exactly one top level\n\t * element call should be made corresponding to `node`.\n\t * @param {!Element} node The Element where the patch should start.\n\t * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.\n\t *     calls that describe the DOM. This should have at most one top level\n\t *     element call.\n\t * @param {T=} data An argument passed to fn to represent DOM state.\n\t * @template T\n\t */\n\tvar patchOuter = patchFactory(function (node, fn, data) {\n\t  currentNode = /** @type {!Element} */{ nextSibling: node };\n\t\n\t  fn(data);\n\t\n\t  if (false) {}\n\t});\n\t\n\t/**\n\t * Checks whether or not the current node matches the specified nodeName and\n\t * key.\n\t *\n\t * @param {?string} nodeName The nodeName for this node.\n\t * @param {?string=} key An optional key that identifies a node.\n\t * @return {boolean} True if the node matches, false otherwise.\n\t */\n\tvar matches = function matches(nodeName, key) {\n\t  var data = getData(currentNode);\n\t\n\t  // Key check is done using double equals as we want to treat a null key the\n\t  // same as undefined. This should be okay as the only values allowed are\n\t  // strings, null and undefined so the == semantics are not too weird.\n\t  return nodeName === data.nodeName && key == data.key;\n\t};\n\t\n\t/**\n\t * Aligns the virtual Element definition with the actual DOM, moving the\n\t * corresponding DOM node to the correct location or creating it if necessary.\n\t * @param {string} nodeName For an Element, this should be a valid tag string.\n\t *     For a Text, this should be #text.\n\t * @param {?string=} key The key used to identify this element.\n\t * @param {?Array<*>=} statics For an Element, this should be an array of\n\t *     name-value pairs.\n\t */\n\tvar alignWithDOM = function alignWithDOM(nodeName, key, statics) {\n\t  if (currentNode && matches(nodeName, key)) {\n\t    return;\n\t  }\n\t\n\t  var node = undefined;\n\t\n\t  // Check to see if the node has moved within the parent.\n\t  if (key) {\n\t    node = getChild(currentParent, key);\n\t    if (node && 'production' !== 'production') {\n\t      assertKeyedTagMatches(getData(node).nodeName, nodeName, key);\n\t    }\n\t  }\n\t\n\t  // Create the node if it doesn't exist.\n\t  if (!node) {\n\t    if (nodeName === '#text') {\n\t      node = createText(doc);\n\t    } else {\n\t      node = createElement(doc, currentParent, nodeName, key, statics);\n\t    }\n\t\n\t    if (key) {\n\t      registerChild(currentParent, key, node);\n\t    }\n\t\n\t    context.markCreated(node);\n\t  }\n\t\n\t  // If the node has a key, remove it from the DOM to prevent a large number\n\t  // of re-orders in the case that it moved far or was completely removed.\n\t  // Since we hold on to a reference through the keyMap, we can always add it\n\t  // back.\n\t  if (currentNode && getData(currentNode).key) {\n\t    currentParent.replaceChild(node, currentNode);\n\t    getData(currentParent).keyMapValid = false;\n\t  } else {\n\t    currentParent.insertBefore(node, currentNode);\n\t  }\n\t\n\t  currentNode = node;\n\t};\n\t\n\t/**\n\t * Clears out any unvisited Nodes, as the corresponding virtual element\n\t * functions were never called for them.\n\t */\n\tvar clearUnvisitedDOM = function clearUnvisitedDOM() {\n\t  var node = currentParent;\n\t  var data = getData(node);\n\t  var keyMap = data.keyMap;\n\t  var keyMapValid = data.keyMapValid;\n\t  var child = node.lastChild;\n\t  var key = undefined;\n\t\n\t  if (child === currentNode && keyMapValid) {\n\t    return;\n\t  }\n\t\n\t  if (data.attrs[symbols.placeholder] && node !== root) {\n\t    if (false) {}\n\t    return;\n\t  }\n\t\n\t  while (child !== currentNode) {\n\t    node.removeChild(child);\n\t    context.markDeleted( /** @type {!Node}*/child);\n\t\n\t    key = getData(child).key;\n\t    if (key) {\n\t      delete keyMap[key];\n\t    }\n\t    child = node.lastChild;\n\t  }\n\t\n\t  // Clean the keyMap, removing any unusued keys.\n\t  if (!keyMapValid) {\n\t    for (key in keyMap) {\n\t      child = keyMap[key];\n\t      if (child.parentNode !== node) {\n\t        context.markDeleted(child);\n\t        delete keyMap[key];\n\t      }\n\t    }\n\t\n\t    data.keyMapValid = true;\n\t  }\n\t};\n\t\n\t/**\n\t * Changes to the first child of the current node.\n\t */\n\tvar enterNode = function enterNode() {\n\t  currentParent = currentNode;\n\t  currentNode = null;\n\t};\n\t\n\t/**\n\t * Changes to the next sibling of the current node.\n\t */\n\tvar nextNode = function nextNode() {\n\t  if (currentNode) {\n\t    currentNode = currentNode.nextSibling;\n\t  } else {\n\t    currentNode = currentParent.firstChild;\n\t  }\n\t};\n\t\n\t/**\n\t * Changes to the parent of the current node, removing any unvisited children.\n\t */\n\tvar exitNode = function exitNode() {\n\t  clearUnvisitedDOM();\n\t\n\t  currentNode = currentParent;\n\t  currentParent = currentParent.parentNode;\n\t};\n\t\n\t/**\n\t * Makes sure that the current node is an Element with a matching tagName and\n\t * key.\n\t *\n\t * @param {string} tag The element's tag.\n\t * @param {?string=} key The key used to identify this element. This can be an\n\t *     empty string, but performance may be better if a unique value is used\n\t *     when iterating over an array of items.\n\t * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n\t *     static attributes for the Element. These will only be set once when the\n\t *     Element is created.\n\t * @return {!Element} The corresponding Element.\n\t */\n\tvar coreElementOpen = function coreElementOpen(tag, key, statics) {\n\t  nextNode();\n\t  alignWithDOM(tag, key, statics);\n\t  enterNode();\n\t  return (/** @type {!Element} */currentParent\n\t  );\n\t};\n\t\n\t/**\n\t * Closes the currently open Element, removing any unvisited children if\n\t * necessary.\n\t *\n\t * @return {!Element} The corresponding Element.\n\t */\n\tvar coreElementClose = function coreElementClose() {\n\t  if (false) {}\n\t\n\t  exitNode();\n\t  return (/** @type {!Element} */currentNode\n\t  );\n\t};\n\t\n\t/**\n\t * Makes sure the current node is a Text node and creates a Text node if it is\n\t * not.\n\t *\n\t * @return {!Text} The corresponding Text Node.\n\t */\n\tvar coreText = function coreText() {\n\t  nextNode();\n\t  alignWithDOM('#text', null, null);\n\t  return (/** @type {!Text} */currentNode\n\t  );\n\t};\n\t\n\t/**\n\t * Gets the current Element being patched.\n\t * @return {!Element}\n\t */\n\tvar currentElement = function currentElement() {\n\t  if (false) {}\n\t  return (/** @type {!Element} */currentParent\n\t  );\n\t};\n\t\n\t/**\n\t * Skips the children in a subtree, allowing an Element to be closed without\n\t * clearing out the children.\n\t */\n\tvar skip = function skip() {\n\t  if (false) {}\n\t  currentNode = currentParent.lastChild;\n\t};\n\t\n\t/**\n\t * The offset in the virtual element declaration where the attributes are\n\t * specified.\n\t * @const\n\t */\n\tvar ATTRIBUTES_OFFSET = 3;\n\t\n\t/**\n\t * Builds an array of arguments for use with elementOpenStart, attr and\n\t * elementOpenEnd.\n\t * @const {Array<*>}\n\t */\n\tvar argsBuilder = [];\n\t\n\t/**\n\t * @param {string} tag The element's tag.\n\t * @param {?string=} key The key used to identify this element. This can be an\n\t *     empty string, but performance may be better if a unique value is used\n\t *     when iterating over an array of items.\n\t * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n\t *     static attributes for the Element. These will only be set once when the\n\t *     Element is created.\n\t * @param {...*} const_args Attribute name/value pairs of the dynamic attributes\n\t *     for the Element.\n\t * @return {!Element} The corresponding Element.\n\t */\n\tvar elementOpen = function elementOpen(tag, key, statics, const_args) {\n\t  if (false) {}\n\t\n\t  var node = coreElementOpen(tag, key, statics);\n\t  var data = getData(node);\n\t\n\t  /*\n\t   * Checks to see if one or more attributes have changed for a given Element.\n\t   * When no attributes have changed, this is much faster than checking each\n\t   * individual argument. When attributes have changed, the overhead of this is\n\t   * minimal.\n\t   */\n\t  var attrsArr = data.attrsArr;\n\t  var newAttrs = data.newAttrs;\n\t  var attrsChanged = false;\n\t  var i = ATTRIBUTES_OFFSET;\n\t  var j = 0;\n\t\n\t  for (; i < arguments.length; i += 1, j += 1) {\n\t    if (attrsArr[j] !== arguments[i]) {\n\t      attrsChanged = true;\n\t      break;\n\t    }\n\t  }\n\t\n\t  for (; i < arguments.length; i += 1, j += 1) {\n\t    attrsArr[j] = arguments[i];\n\t  }\n\t\n\t  if (j < attrsArr.length) {\n\t    attrsChanged = true;\n\t    attrsArr.length = j;\n\t  }\n\t\n\t  /*\n\t   * Actually perform the attribute update.\n\t   */\n\t  if (attrsChanged) {\n\t    for (i = ATTRIBUTES_OFFSET; i < arguments.length; i += 2) {\n\t      newAttrs[arguments[i]] = arguments[i + 1];\n\t    }\n\t\n\t    for (var _attr in newAttrs) {\n\t      updateAttribute(node, _attr, newAttrs[_attr]);\n\t      newAttrs[_attr] = undefined;\n\t    }\n\t  }\n\t\n\t  return node;\n\t};\n\t\n\t/**\n\t * Declares a virtual Element at the current location in the document. This\n\t * corresponds to an opening tag and a elementClose tag is required. This is\n\t * like elementOpen, but the attributes are defined using the attr function\n\t * rather than being passed as arguments. Must be folllowed by 0 or more calls\n\t * to attr, then a call to elementOpenEnd.\n\t * @param {string} tag The element's tag.\n\t * @param {?string=} key The key used to identify this element. This can be an\n\t *     empty string, but performance may be better if a unique value is used\n\t *     when iterating over an array of items.\n\t * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n\t *     static attributes for the Element. These will only be set once when the\n\t *     Element is created.\n\t */\n\tvar elementOpenStart = function elementOpenStart(tag, key, statics) {\n\t  if (false) {}\n\t\n\t  argsBuilder[0] = tag;\n\t  argsBuilder[1] = key;\n\t  argsBuilder[2] = statics;\n\t};\n\t\n\t/***\n\t * Defines a virtual attribute at this point of the DOM. This is only valid\n\t * when called between elementOpenStart and elementOpenEnd.\n\t *\n\t * @param {string} name\n\t * @param {*} value\n\t */\n\tvar attr = function attr(name, value) {\n\t  if (false) {}\n\t\n\t  argsBuilder.push(name, value);\n\t};\n\t\n\t/**\n\t * Closes an open tag started with elementOpenStart.\n\t * @return {!Element} The corresponding Element.\n\t */\n\tvar elementOpenEnd = function elementOpenEnd() {\n\t  if (false) {}\n\t\n\t  var node = elementOpen.apply(null, argsBuilder);\n\t  argsBuilder.length = 0;\n\t  return node;\n\t};\n\t\n\t/**\n\t * Closes an open virtual Element.\n\t *\n\t * @param {string} tag The element's tag.\n\t * @return {!Element} The corresponding Element.\n\t */\n\tvar elementClose = function elementClose(tag) {\n\t  if (false) {}\n\t\n\t  var node = coreElementClose();\n\t\n\t  if (false) {}\n\t\n\t  return node;\n\t};\n\t\n\t/**\n\t * Declares a virtual Element at the current location in the document that has\n\t * no children.\n\t * @param {string} tag The element's tag.\n\t * @param {?string=} key The key used to identify this element. This can be an\n\t *     empty string, but performance may be better if a unique value is used\n\t *     when iterating over an array of items.\n\t * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n\t *     static attributes for the Element. These will only be set once when the\n\t *     Element is created.\n\t * @param {...*} const_args Attribute name/value pairs of the dynamic attributes\n\t *     for the Element.\n\t * @return {!Element} The corresponding Element.\n\t */\n\tvar elementVoid = function elementVoid(tag, key, statics, const_args) {\n\t  elementOpen.apply(null, arguments);\n\t  return elementClose(tag);\n\t};\n\t\n\t/**\n\t * Declares a virtual Element at the current location in the document that is a\n\t * placeholder element. Children of this Element can be manually managed and\n\t * will not be cleared by the library.\n\t *\n\t * A key must be specified to make sure that this node is correctly preserved\n\t * across all conditionals.\n\t *\n\t * @param {string} tag The element's tag.\n\t * @param {string} key The key used to identify this element.\n\t * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n\t *     static attributes for the Element. These will only be set once when the\n\t *     Element is created.\n\t * @param {...*} const_args Attribute name/value pairs of the dynamic attributes\n\t *     for the Element.\n\t * @return {!Element} The corresponding Element.\n\t */\n\tvar elementPlaceholder = function elementPlaceholder(tag, key, statics, const_args) {\n\t  if (false) {}\n\t\n\t  elementOpen.apply(null, arguments);\n\t  skip();\n\t  return elementClose(tag);\n\t};\n\t\n\t/**\n\t * Declares a virtual Text at this point in the document.\n\t *\n\t * @param {string|number|boolean} value The value of the Text.\n\t * @param {...(function((string|number|boolean)):string)} const_args\n\t *     Functions to format the value which are called only when the value has\n\t *     changed.\n\t * @return {!Text} The corresponding text node.\n\t */\n\tvar text = function text(value, const_args) {\n\t  if (false) {}\n\t\n\t  var node = coreText();\n\t  var data = getData(node);\n\t\n\t  if (data.text !== value) {\n\t    data.text = /** @type {string} */value;\n\t\n\t    var formatted = value;\n\t    for (var i = 1; i < arguments.length; i += 1) {\n\t      /*\n\t       * Call the formatter function directly to prevent leaking arguments.\n\t       * https://github.com/google/incremental-dom/pull/204#issuecomment-178223574\n\t       */\n\t      var fn = arguments[i];\n\t      formatted = fn(formatted);\n\t    }\n\t\n\t    node.data = formatted;\n\t  }\n\t\n\t  return node;\n\t};\n\t\n\texports.patch = patchInner;\n\texports.patchInner = patchInner;\n\texports.patchOuter = patchOuter;\n\texports.currentElement = currentElement;\n\texports.skip = skip;\n\texports.elementVoid = elementVoid;\n\texports.elementOpenStart = elementOpenStart;\n\texports.elementOpenEnd = elementOpenEnd;\n\texports.elementOpen = elementOpen;\n\texports.elementClose = elementClose;\n\texports.elementPlaceholder = elementPlaceholder;\n\texports.text = text;\n\texports.attr = attr;\n\texports.symbols = symbols;\n\texports.attributes = attributes;\n\texports.applyAttr = applyAttr;\n\texports.applyProp = applyProp;\n\texports.notifications = notifications;\n\t\n\t//# sourceMappingURL=incremental-dom-cjs.js.map\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\tvar doc = document;\n\tvar win = window;\n\tvar div = doc.createElement('div');\n\tvar customElementsV0 = exports.customElementsV0 = !!doc.registerElement;\n\tvar customElementsV1 = exports.customElementsV1 = !!win.customElements;\n\tvar shadowDomV0 = exports.shadowDomV0 = !!div.createShadowRoot;\n\tvar shadowDomV1 = exports.shadowDomV1 = !!div.attachShadow;\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _symbols = __webpack_require__(5);\n\t\n\tvar _support = __webpack_require__(8);\n\t\n\tvar _data = __webpack_require__(10);\n\t\n\tvar _data2 = _interopRequireDefault(_data);\n\t\n\tvar _debounce = __webpack_require__(11);\n\t\n\tvar _debounce2 = _interopRequireDefault(_debounce);\n\t\n\tvar _getOwnPropertyDescriptors = __webpack_require__(12);\n\t\n\tvar _getOwnPropertyDescriptors2 = _interopRequireDefault(_getOwnPropertyDescriptors);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar Component = function (_HTMLElement) {\n\t  _inherits(Component, _HTMLElement);\n\t\n\t  function Component() {\n\t    _classCallCheck(this, Component);\n\t\n\t    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Component).call(this));\n\t\n\t    _this.createdCallback();\n\t    return _this;\n\t  }\n\t\n\t  _createClass(Component, [{\n\t    key: 'connectedCallback',\n\t    value: function connectedCallback() {\n\t      var ctor = this.constructor;\n\t      var attached = ctor.attached;\n\t\n\t      var render = ctor[_symbols.renderer];\n\t      this[_symbols.connected] = true;\n\t      if (typeof render === 'function') {\n\t        render(this);\n\t      }\n\t      if (typeof attached === 'function') {\n\t        attached(this);\n\t      }\n\t    }\n\t  }, {\n\t    key: 'disconnectedCallback',\n\t    value: function disconnectedCallback() {\n\t      var detached = this.constructor.detached;\n\t\n\t      this[_symbols.connected] = false;\n\t      if (typeof detached === 'function') {\n\t        detached(this);\n\t      }\n\t    }\n\t  }, {\n\t    key: 'attributeChangedCallback',\n\t    value: function attributeChangedCallback(name, oldValue, newValue) {\n\t      var _constructor = this.constructor;\n\t      var attributeChanged = _constructor.attributeChanged;\n\t      var observedAttributes = _constructor.observedAttributes;\n\t\n\t      var propertyName = (0, _data2.default)(this, 'attributeLinks')[name];\n\t\n\t      // In V0 we have to ensure the attribute is being observed.\n\t      if (_support.customElementsV0 && observedAttributes.indexOf(name) === -1) {\n\t        return;\n\t      }\n\t\n\t      if (propertyName) {\n\t        var propData = (0, _data2.default)(this, 'api/property/' + propertyName);\n\t\n\t        // This ensures a property set doesn't cause the attribute changed\n\t        // handler to run again once we set this flag. This only ever has a\n\t        // chance to run when you set an attribute, it then sets a property and\n\t        // then that causes the attribute to be set again.\n\t        if (propData.syncingAttribute) {\n\t          propData.syncingAttribute = false;\n\t        } else {\n\t          // Sync up the property.\n\t          var propOpts = this.constructor.props[propertyName];\n\t          propData.settingAttribute = true;\n\t          this[propertyName] = newValue !== null && propOpts.deserialize ? propOpts.deserialize(newValue) : newValue;\n\t        }\n\t      }\n\t\n\t      if (attributeChanged) {\n\t        attributeChanged(this, { name: name, newValue: newValue, oldValue: oldValue });\n\t      }\n\t    }\n\t  }, {\n\t    key: 'createdCallback',\n\t    value: function createdCallback() {\n\t      var _this2 = this;\n\t\n\t      var elemData = (0, _data2.default)(this);\n\t      var readyCallbacks = elemData.readyCallbacks;\n\t      var Ctor = this.constructor;\n\t      var created = Ctor.created;\n\t      var observedAttributes = Ctor.observedAttributes;\n\t      var props = Ctor.props;\n\t\n\t      // Ensures that this can never be called twice.\n\t\n\t      if (this[_symbols.created]) return;\n\t      this[_symbols.created] = true;\n\t\n\t      // Set up a renderer that is debounced for property sets to call directly.\n\t      this[_symbols.rendererDebounced] = (0, _debounce2.default)(Ctor[_symbols.renderer]);\n\t\n\t      if (props) {\n\t        Ctor[_symbols.props](this);\n\t      }\n\t\n\t      if (created) {\n\t        created(this);\n\t      }\n\t\n\t      if (readyCallbacks) {\n\t        readyCallbacks.forEach(function (cb) {\n\t          return cb(_this2);\n\t        });\n\t        delete elemData.readyCallbacks;\n\t      }\n\t\n\t      // In v0 we must ensure the attributeChangedCallback is called for attrs\n\t      // that aren't linked to props so that the callback behaves the same no\n\t      // matter if v0 or v1 is being used.\n\t      if (_support.customElementsV0) {\n\t        observedAttributes.forEach(function (name) {\n\t          var propertyName = (0, _data2.default)(_this2, 'attributeLinks')[name];\n\t          if (!propertyName) {\n\t            _this2.attributeChangedCallback(name, null, _this2.getAttribute(name));\n\t          }\n\t        });\n\t      }\n\t    }\n\t  }, {\n\t    key: 'attachedCallback',\n\t    value: function attachedCallback() {\n\t      this.connectedCallback();\n\t    }\n\t  }, {\n\t    key: 'detachedCallback',\n\t    value: function detachedCallback() {\n\t      this.disconnectedCallback();\n\t    }\n\t  }], [{\n\t    key: 'extend',\n\t    value: function extend() {\n\t      var definition = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t      var Base = arguments.length <= 1 || arguments[1] === undefined ? this : arguments[1];\n\t\n\t      // Create class for the user.\n\t      var Ctor = function (_Base) {\n\t        _inherits(Ctor, _Base);\n\t\n\t        function Ctor() {\n\t          _classCallCheck(this, Ctor);\n\t\n\t          return _possibleConstructorReturn(this, Object.getPrototypeOf(Ctor).apply(this, arguments));\n\t        }\n\t\n\t        return Ctor;\n\t      }(Base);\n\t\n\t      // For inheriting from the object literal.\n\t\n\t\n\t      var opts = (0, _getOwnPropertyDescriptors2.default)(definition);\n\t      var prot = (0, _getOwnPropertyDescriptors2.default)(definition.prototype);\n\t\n\t      // Prototype is non configurable (but is writable) s\n\t      delete opts.prototype;\n\t\n\t      // Pass on static and instance members from the definition.\n\t      Object.defineProperties(Ctor, opts);\n\t      Object.defineProperties(Ctor.prototype, prot);\n\t\n\t      return Ctor;\n\t    }\n\t\n\t    // This is a default implementation that does strict equality copmarison on\n\t    // prevoius props and next props. It synchronously renders on the first prop\n\t    // that is different and returns immediately.\n\t\n\t  }, {\n\t    key: 'updated',\n\t    value: function updated(elem, prev) {\n\t      if (!prev) {\n\t        return true;\n\t      }\n\t\n\t      for (var name in prev) {\n\t        // eslint-disable-line no-restricted-syntax\n\t        if (prev[name] !== elem[name]) {\n\t          return true;\n\t        }\n\t      }\n\t    }\n\t  }, {\n\t    key: 'observedAttributes',\n\t    get: function get() {\n\t      return [];\n\t    }\n\t  }, {\n\t    key: 'props',\n\t    get: function get() {\n\t      return {};\n\t    }\n\t  }]);\n\t\n\t  return Component;\n\t}(HTMLElement);\n\t\n\texports.default = Component;\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\texports.default = function (element) {\n\t  var namespace = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];\n\t\n\t  var data = element.__SKATE_DATA || (element.__SKATE_DATA = {});\n\t  return namespace && (data[namespace] || (data[namespace] = {})) || data;\n\t};\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\texports.default = function (fn) {\n\t  var _this = this;\n\t\n\t  var called = false;\n\t  return function () {\n\t    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t      args[_key] = arguments[_key];\n\t    }\n\t\n\t    if (!called) {\n\t      called = true;\n\t      setTimeout(function () {\n\t        called = false;\n\t        fn.apply(_this, args);\n\t      });\n\t    }\n\t  };\n\t};\n\n/***/ },\n/* 12 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\texports.default = function (obj) {\n\t  return Object.getOwnPropertyNames(obj || {}).reduce(function (prev, curr) {\n\t    prev[curr] = Object.getOwnPropertyDescriptor(obj, curr);\n\t    return prev;\n\t  }, {});\n\t};\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\t\n\texports.default = function (name, opts) {\n\t  if (opts === undefined) {\n\t    throw new Error('You have to define options to register a component ' + name);\n\t  }\n\t\n\t  var uniqueName = generateUniqueName(name);\n\t  var Ctor = (typeof opts === 'undefined' ? 'undefined' : _typeof(opts)) === 'object' ? _component2.default.extend(opts) : opts;\n\t\n\t  formatLinkedAttributes(Ctor);\n\t\n\t  Ctor[_symbols.name] = uniqueName;\n\t  Ctor[_symbols.props] = createInitProps(Ctor);\n\t  Ctor[_symbols.renderer] = (0, _render2.default)(Ctor);\n\t\n\t  if (_support.customElementsV1) {\n\t    window.customElements.define(uniqueName, Ctor, { extends: Ctor.extends });\n\t  } else if (_support.customElementsV0) {\n\t    return document.registerElement(uniqueName, Ctor);\n\t  } else {\n\t    throw new Error('Skate requires native custom element support or a polyfill.');\n\t  }\n\t\n\t  return Ctor;\n\t};\n\t\n\tvar _symbols = __webpack_require__(5);\n\t\n\tvar _support = __webpack_require__(8);\n\t\n\tvar _component = __webpack_require__(9);\n\t\n\tvar _component2 = _interopRequireDefault(_component);\n\t\n\tvar _render = __webpack_require__(14);\n\t\n\tvar _render2 = _interopRequireDefault(_render);\n\t\n\tvar _dashCase = __webpack_require__(16);\n\t\n\tvar _dashCase2 = _interopRequireDefault(_dashCase);\n\t\n\tvar _propsInit = __webpack_require__(17);\n\t\n\tvar _propsInit2 = _interopRequireDefault(_propsInit);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar registry = {};\n\t\n\t// Ensures that definitions passed as part of the constructor are functions\n\t// that return property definitions used on the element.\n\tfunction ensurePropertyFunctions(Ctor) {\n\t  var props = Ctor.props;\n\t  var names = Object.keys(props || {});\n\t  return names.reduce(function (descriptors, descriptorName) {\n\t    descriptors[descriptorName] = props[descriptorName];\n\t    if (typeof descriptors[descriptorName] !== 'function') {\n\t      descriptors[descriptorName] = (0, _propsInit2.default)(descriptors[descriptorName]);\n\t    }\n\t    return descriptors;\n\t  }, {});\n\t}\n\t\n\t// Ensures the property definitions are transformed to objects that can be used\n\t// to create properties on the element.\n\tfunction ensurePropertyDefinitions(Ctor) {\n\t  var props = ensurePropertyFunctions(Ctor);\n\t  return Object.keys(props).reduce(function (descriptors, descriptorName) {\n\t    descriptors[descriptorName] = props[descriptorName](descriptorName);\n\t    return descriptors;\n\t  }, {});\n\t}\n\t\n\t// Ensures linked properties that have linked attributes are pre-formatted to\n\t// the attribute name in which they are linked.\n\tfunction formatLinkedAttributes(Ctor) {\n\t  var observedAttributes = Ctor.observedAttributes;\n\t  var props = Ctor.props;\n\t\n\t\n\t  if (!props) {\n\t    return;\n\t  }\n\t\n\t  Object.keys(props).forEach(function (name) {\n\t    var prop = props[name];\n\t    var attr = prop.attribute;\n\t    if (attr) {\n\t      // Ensure the property is updated.\n\t      var linkedAttr = prop.attribute = attr === true ? (0, _dashCase2.default)(name) : attr;\n\t\n\t      // Automatically observe the attribute since they're linked from the\n\t      // attributeChangedCallback.\n\t      if (observedAttributes.indexOf(linkedAttr) === -1) {\n\t        observedAttributes.push(linkedAttr);\n\t      }\n\t    }\n\t  });\n\t\n\t  // Merge observed attributes.\n\t  Object.defineProperty(Ctor, 'observedAttributes', {\n\t    configurable: true,\n\t    enumerable: true,\n\t    get: function get() {\n\t      return observedAttributes;\n\t    }\n\t  });\n\t}\n\t\n\tfunction createInitProps(Ctor) {\n\t  var props = ensurePropertyDefinitions(Ctor);\n\t\n\t  return function (elem) {\n\t    if (!props) {\n\t      return;\n\t    }\n\t\n\t    Object.keys(props).forEach(function (name) {\n\t      var prop = props[name];\n\t      prop.created(elem);\n\t\n\t      // https://bugs.webkit.org/show_bug.cgi?id=49739\n\t      //\n\t      // When Webkit fixes that bug so that native property accessors can be\n\t      // retrieved, we can move defining the property to the prototype and away\n\t      // from having to do if for every instance as all other browsers support\n\t      // this.\n\t      Object.defineProperty(elem, name, prop);\n\t    });\n\t  };\n\t}\n\t\n\tfunction generateUniqueName(name) {\n\t  // we don't need to generate a unique name if it's the first time\n\t  if (!registry[name]) {\n\t    registry[name] = true;\n\t    return name;\n\t  }\n\t  // http://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript/2117523#2117523\n\t  var rand = 'xxxxxxxx'.replace(/[xy]/g, function (c) {\n\t    var r = Math.random() * 16 | 0;\n\t    var v = c === 'x' ? r : r & 0x3 | 0x8;\n\t    return v.toString(16);\n\t  });\n\t\n\t  return name + '-' + rand;\n\t}\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\texports.default = function (Ctor) {\n\t  var render = Ctor.render;\n\t  var rendered = Ctor.rendered;\n\t  var updated = Ctor.updated;\n\t\n\t\n\t  return function (elem) {\n\t    if (elem[_symbols.rendering] || !elem[_symbols.connected]) {\n\t      return;\n\t    }\n\t\n\t    // Flag as rendering. This prevents anything from trying to render - or\n\t    // queueing a render - while there is a pending render.\n\t    elem[_symbols.rendering] = true;\n\t\n\t    // Call the updated() callback to see if we should render.\n\t    var shouldRender = true;\n\t    if (updated) {\n\t      var prev = elem[_symbols.props];\n\t      elem[_symbols.props] = (0, _props2.default)(elem);\n\t      shouldRender = updated(elem, prev);\n\t    }\n\t\n\t    // Even though this would ideally be checked in the updated() callback,\n\t    // it may not be, so we ensure that there is a point in proceeding.\n\t    if (!render) {\n\t      elem[_symbols.rendering] = false;\n\t      return;\n\t    }\n\t\n\t    // Try and get the current shadow root (will be setup if not).\n\t    var sr = elem[_symbols.shadowRoot];\n\t\n\t    // Setup the shadow root if it hasn't been setup yet.\n\t    if (!sr) {\n\t      if (_support.shadowDomV1) {\n\t        sr = elem.attachShadow({ mode: 'open' });\n\t      } else if (_support.shadowDomV0) {\n\t        sr = elem.createShadowRoot();\n\t      } else {\n\t        sr = elem;\n\t      }\n\t\n\t      elem[_symbols.shadowRoot] = sr;\n\t    }\n\t\n\t    if (shouldRender) {\n\t      (0, _incrementalDom.patchInner)(sr, render, elem);\n\t      if (rendered) {\n\t        rendered(elem);\n\t      }\n\t    }\n\t\n\t    elem[_symbols.rendering] = false;\n\t  };\n\t};\n\t\n\tvar _incrementalDom = __webpack_require__(7);\n\t\n\tvar _symbols = __webpack_require__(5);\n\t\n\tvar _support = __webpack_require__(8);\n\t\n\tvar _props = __webpack_require__(15);\n\t\n\tvar _props2 = _interopRequireDefault(_props);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\texports.default = function (elem, newProps) {\n\t  return typeof newProps === 'undefined' ? get(elem) : set(elem, newProps);\n\t};\n\t\n\tvar _symbols = __webpack_require__(5);\n\t\n\tvar _assign = __webpack_require__(2);\n\t\n\tvar _assign2 = _interopRequireDefault(_assign);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction get(elem) {\n\t  var props = {};\n\t  Object.keys(elem.constructor.props).forEach(function (key) {\n\t    props[key] = elem[key];\n\t  });\n\t\n\t  return props;\n\t}\n\t\n\tfunction set(elem, newProps) {\n\t  (0, _assign2.default)(elem, newProps);\n\t  if (elem.constructor.render) {\n\t    elem.constructor[_symbols.renderer](elem);\n\t  }\n\t}\n\n/***/ },\n/* 16 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\texports.default = function (str) {\n\t  return str.split(/([A-Z])/).reduce(function (one, two, idx) {\n\t    var dash = !one || idx % 2 === 0 ? '' : '-';\n\t    return '' + one + dash + two.toLowerCase();\n\t  });\n\t};\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\texports.default = function (opts) {\n\t  opts = opts || {};\n\t\n\t  if (typeof opts === 'function') {\n\t    opts = { coerce: opts };\n\t  }\n\t\n\t  return function (name) {\n\t    return createNativePropertyDefinition(name, (0, _assign2.default)({\n\t      default: null,\n\t      deserialize: function deserialize(value) {\n\t        return value;\n\t      },\n\t      serialize: function serialize(value) {\n\t        return value;\n\t      }\n\t    }, opts));\n\t  };\n\t};\n\t\n\tvar _symbols = __webpack_require__(5);\n\t\n\tvar _assign = __webpack_require__(2);\n\t\n\tvar _assign2 = _interopRequireDefault(_assign);\n\t\n\tvar _data = __webpack_require__(10);\n\t\n\tvar _data2 = _interopRequireDefault(_data);\n\t\n\tvar _empty = __webpack_require__(3);\n\t\n\tvar _empty2 = _interopRequireDefault(_empty);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction getDefaultValue(elem, name, opts) {\n\t  return typeof opts.default === 'function' ? opts.default(elem, { name: name }) : opts.default;\n\t}\n\t\n\tfunction getInitialValue(elem, name, opts) {\n\t  return typeof opts.initial === 'function' ? opts.initial(elem, { name: name }) : opts.initial;\n\t}\n\t\n\tfunction createNativePropertyDefinition(name, opts) {\n\t  var prop = {\n\t    configurable: true,\n\t    enumerable: true\n\t  };\n\t\n\t  prop.created = function (elem) {\n\t    // eslint-disable-line func-names\n\t    var propData = (0, _data2.default)(elem, 'api/property/' + name);\n\t    var attributeName = opts.attribute;\n\t    var initialValue = elem[name];\n\t    var shouldSyncAttribute = false;\n\t\n\t    // Store property to attribute link information.\n\t    (0, _data2.default)(elem, 'attributeLinks')[attributeName] = name;\n\t    (0, _data2.default)(elem, 'propertyLinks')[name] = attributeName;\n\t\n\t    // Set up initial value if it wasn't specified.\n\t    if ((0, _empty2.default)(initialValue)) {\n\t      if (attributeName && elem.hasAttribute(attributeName)) {\n\t        initialValue = opts.deserialize(elem.getAttribute(attributeName));\n\t      } else if ('initial' in opts) {\n\t        initialValue = getInitialValue(elem, name, opts);\n\t        shouldSyncAttribute = true;\n\t      } else if ('default' in opts) {\n\t        initialValue = getDefaultValue(elem, name, opts);\n\t      }\n\t    }\n\t\n\t    if (shouldSyncAttribute) {\n\t      prop.set.call(elem, initialValue);\n\t    } else {\n\t      propData.internalValue = opts.coerce ? opts.coerce(initialValue) : initialValue;\n\t    }\n\t  };\n\t\n\t  prop.get = function () {\n\t    // eslint-disable-line func-names\n\t    var propData = (0, _data2.default)(this, 'api/property/' + name);\n\t    var internalValue = propData.internalValue;\n\t\n\t    if (typeof opts.get === 'function') {\n\t      return opts.get(this, { name: name, internalValue: internalValue });\n\t    }\n\t    return internalValue;\n\t  };\n\t\n\t  prop.set = function (newValue) {\n\t    // eslint-disable-line func-names\n\t    var propData = (0, _data2.default)(this, 'api/property/' + name);\n\t    var oldValue = propData.oldValue;\n\t\n\t    var shouldRemoveAttribute = false;\n\t\n\t    if ((0, _empty2.default)(oldValue)) {\n\t      oldValue = null;\n\t    }\n\t\n\t    if ((0, _empty2.default)(newValue)) {\n\t      newValue = getDefaultValue(this, name, opts);\n\t      shouldRemoveAttribute = true;\n\t    }\n\t\n\t    if (typeof opts.coerce === 'function') {\n\t      newValue = opts.coerce(newValue);\n\t    }\n\t\n\t    propData.internalValue = newValue;\n\t\n\t    var changeData = { name: name, newValue: newValue, oldValue: oldValue };\n\t\n\t    if (typeof opts.set === 'function') {\n\t      opts.set(this, changeData);\n\t    }\n\t\n\t    // Queue a re-render only if it's not currently rendering.\n\t    if (!this[_symbols.rendering]) {\n\t      this[_symbols.rendererDebounced](this);\n\t    }\n\t\n\t    propData.oldValue = newValue;\n\t\n\t    // Link up the attribute.\n\t    var attributeName = (0, _data2.default)(this, 'propertyLinks')[name];\n\t    if (attributeName && !propData.settingAttribute) {\n\t      var serializedValue = opts.serialize(newValue);\n\t      propData.syncingAttribute = true;\n\t      if (shouldRemoveAttribute || (0, _empty2.default)(serializedValue)) {\n\t        this.removeAttribute(attributeName);\n\t      } else {\n\t        this.setAttribute(attributeName, serializedValue);\n\t      }\n\t    }\n\t\n\t    // Allow the attribute to be linked again.\n\t    propData.settingAttribute = false;\n\t  };\n\t\n\t  return prop;\n\t}\n\n/***/ },\n/* 18 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\texports.default = function (elem, name) {\n\t  var opts = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\t\n\t  if (opts.bubbles === undefined) {\n\t    opts.bubbles = true;\n\t  }\n\t  if (opts.cancelable === undefined) {\n\t    opts.cancelable = true;\n\t  }\n\t  return elem.disabled ? true : elem.dispatchEvent(createCustomEvent(name, opts));\n\t};\n\t\n\tvar CustomEvent = function (Event) {\n\t  if (Event) {\n\t    try {\n\t      new Event(); // eslint-disable-line no-new\n\t    } catch (e) {\n\t      return undefined;\n\t    }\n\t  }\n\t  return Event;\n\t}(window.CustomEvent);\n\t\n\tfunction createCustomEvent(name) {\n\t  var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\t\n\t  if (CustomEvent) {\n\t    return new CustomEvent(name, opts);\n\t  }\n\t  var e = document.createEvent('CustomEvent');\n\t  e.initCustomEvent(name, opts.bubbles, opts.cancelable, opts.detail);\n\t  return e;\n\t}\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\texports.default = function (elem, target) {\n\t  return function (e) {\n\t    var value = getValue(e.target);\n\t    var localTarget = target || e.target.name || 'value';\n\t\n\t    if (localTarget.indexOf('.') > -1) {\n\t      var parts = localTarget.split('.');\n\t      var firstPart = parts[0];\n\t      var propName = parts.pop();\n\t      var obj = parts.reduce(function (prev, curr) {\n\t        return prev && prev[curr];\n\t      }, elem);\n\t\n\t      obj[propName || e.target.name] = value;\n\t      (0, _props4.default)(elem, _defineProperty({}, firstPart, elem[firstPart]));\n\t    } else {\n\t      (0, _props4.default)(elem, _defineProperty({}, localTarget, value));\n\t    }\n\t  };\n\t};\n\t\n\tvar _props3 = __webpack_require__(15);\n\t\n\tvar _props4 = _interopRequireDefault(_props3);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\t\n\tfunction getValue(elem) {\n\t  var type = elem.type;\n\t  if (type === 'checkbox' || type === 'radio') {\n\t    return elem.checked ? elem.value || true : false;\n\t  }\n\t  return elem.value;\n\t}\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\texports.default = function (elem, done) {\n\t  var info = (0, _data2.default)(elem);\n\t  if (elem[_symbols.created]) {\n\t    done(elem);\n\t  } else if (info.readyCallbacks) {\n\t    info.readyCallbacks.push(done);\n\t  } else {\n\t    info.readyCallbacks = [done];\n\t  }\n\t};\n\t\n\tvar _symbols = __webpack_require__(5);\n\t\n\tvar _data = __webpack_require__(10);\n\t\n\tvar _data2 = _interopRequireDefault(_data);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** dist/index-with-deps.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 3113d29c60dbb1c7716a\n **/","import * as prop from './api/prop';\nimport * as symbols from './api/symbols';\nimport * as vdom from './api/vdom';\nimport Component from './api/component';\nimport define from './api/define';\nimport emit from './api/emit';\nimport link from './api/link';\nimport props from './api/props';\nimport ready from './api/ready';\n\nexport {\n  Component,\n  define,\n  emit,\n  link,\n  prop,\n  props,\n  ready,\n  symbols,\n  vdom,\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/index.js\n **/","import assign from '../util/assign';\nimport empty from '../util/empty';\n\nconst alwaysUndefinedIfNotANumberOrNumber = (val) => (isNaN(val) ? undefined : Number(val));\nconst alwaysUndefinedIfEmptyOrString = (val) => (empty(val) ? undefined : String(val));\n\nexport function create(def) {\n  return (...args) => {\n    args.unshift({}, def);\n    return assign.apply(null, args);\n  };\n}\n\nexport const array = create({\n  coerce: (val) => (Array.isArray(val) ? val : [val]),\n  default: () => [],\n  deserialize: JSON.parse,\n  serialize: JSON.stringify,\n});\n\nexport const boolean = create({\n  coerce: value => !!value,\n  default: false,\n  deserialize: value => !(value === null),\n  serialize: value => (value ? '' : undefined),\n});\n\nexport const number = create({\n  default: 0,\n  coerce: alwaysUndefinedIfNotANumberOrNumber,\n  deserialize: alwaysUndefinedIfNotANumberOrNumber,\n  serialize: alwaysUndefinedIfNotANumberOrNumber,\n});\n\nexport const string = create({\n  default: '',\n  coerce: alwaysUndefinedIfEmptyOrString,\n  deserialize: alwaysUndefinedIfEmptyOrString,\n  serialize: alwaysUndefinedIfEmptyOrString,\n});\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/api/prop.js\n **/","const assign = Object.assign;\nexport default assign ? assign.bind(Object) : (obj, ...args) => {\n  args.forEach(arg => Object.keys(arg).forEach(name => obj[name] = arg[name])); // eslint-disable-line no-return-assign\n  return obj;\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/util/assign.js\n **/","export default function (val) {\n  return typeof val === 'undefined' || val === null;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/util/empty.js\n **/","export { name, shadowRoot } from '../util/symbols';\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/api/symbols.js\n **/","export const connected = '____skate_connected';\nexport const created = '____skate_created';\nexport const name = '____skate_name';\nexport const props = '____skate_props';\nexport const ref = '____skate_ref';\nexport const renderer = '____skate_renderer';\nexport const rendering = '____skate_rendering';\nexport const rendererDebounced = '____skate_rendererDebounced';\nexport const shadowRoot = '____skate_shadowRoot';\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/util/symbols.js\n **/","import {\n  applyProp,\n  attr,\n  attributes,\n  elementClose,\n  elementOpen,\n  elementOpenEnd,\n  elementOpenStart,\n  elementVoid,\n  skip,\n  symbols,\n  text,\n} from 'incremental-dom';\nimport { name as $name, ref as $ref } from '../util/symbols';\nimport { shadowDomV0, shadowDomV1 } from '../util/support';\n\nconst applyDefault = attributes[symbols.default];\nconst fallbackToV0 = !shadowDomV1 && shadowDomV0;\nconst stackChren = [];\nconst stackProps = [];\n\n// Adds or removes an event listener for an element.\nfunction applyEvent(elem, ename, newFunc) {\n  let events = elem.__events;\n\n  if (!events) {\n    events = elem.__events = {};\n  }\n\n  const oldFunc = events[ename];\n\n  // Remove old listener so they don't double up.\n  if (oldFunc) {\n    elem.removeEventListener(ename, oldFunc);\n  }\n\n  // Bind new listener.\n  if (newFunc) {\n    elem.addEventListener(ename, events[ename] = newFunc);\n  }\n}\n\n// Attributes that are not handled by Incremental DOM.\nattributes.key = attributes.skip = attributes.statics = function () {};\n\n// Attributes that *must* be set via a property on all elements.\nattributes.checked = attributes.className = attributes.disabled = attributes.value = applyProp;\n\n// Default attribute applicator.\nattributes[symbols.default] = function (elem, name, value) {\n  // If the skip attribute was specified, skip\n  if (name === 'skip' && value) {\n    return skip();\n  }\n\n  // Add the ref to the element so it can be called when it's closed.\n  if (name === 'ref') {\n    elem[$ref] = value;\n    return;\n  }\n\n  // Custom element properties should be set as properties.\n  const props = elem.constructor.props;\n  if (props && name in props) {\n    return applyProp(elem, name, value);\n  }\n\n  // Boolean false values should not set attributes at all.\n  if (value === false) {\n    return;\n  }\n\n  // Handle built-in and custom events.\n  if (name.indexOf('on') === 0) {\n    const firstChar = name[2];\n    let eventName;\n\n    if (firstChar === '-') {\n      eventName = name.substring(3);\n    } else if (firstChar === firstChar.toUpperCase()) {\n      eventName = firstChar.toLowerCase() + name.substring(3);\n    }\n\n    if (eventName) {\n      applyEvent(elem, eventName, value);\n      return;\n    }\n  }\n\n  // Set the select attribute instead of name if it was a <slot> translated to\n  // a <content> for v0.\n  if (name === 'name' && elem.tagName === 'CONTENT') {\n    name = 'select';\n    value = `[slot=\"${value}\"]`;\n  }\n\n  // Set defined props on the element directly.\n  if (name in elem) {\n    applyProp(elem, name, value);\n    return;\n  }\n\n  // Fallback to default IncrementalDOM behaviour.\n  applyDefault(elem, name, value);\n};\n\n\nfunction resolveTagName(tname) {\n  // If the tag name is a function, a Skate constructor or a standard function\n  // is supported.\n  //\n  // - If a Skate constructor, the tag name is extracted from that.\n  // - If a standard function, it is used as a helper.\n  if (typeof tname === 'function') {\n    return tname[$name] || tname;\n  }\n\n  // Skate allows the consumer to use <slot /> and it will translate it to\n  // <content /> if Shadow DOM V0 is preferred.\n  if (tname === 'slot' && fallbackToV0) {\n    return 'content';\n  }\n\n  // All other tag names are just passed through.\n  return tname;\n}\n\nfunction wrapIdomFunc(func, tnameFuncHandler = () => {}) {\n  return function wrap(...args) {\n    args[0] = resolveTagName(args[0]);\n    if (typeof args[0] === 'function') {\n      // If we've encountered a function, handle it according to the type of\n      // function that is being wrapped.\n      return tnameFuncHandler(...args);\n    } else if (stackChren.length) {\n      // We pass the wrap() function in here so that when it's called as\n      // children, it will queue up for the next stack, if there is one.\n      stackChren[stackChren.length - 1].push([wrap, args]);\n    } else {\n      // If there is no stack left, we call Incremental DOM directly.\n      const elem = func(...args);\n\n      // If we're in elementClose, try calling the ref.\n      if (func === elementClose) {\n        const eref = elem[$ref];\n        if (typeof eref === 'function') {\n          eref(elem);\n        }\n      }\n\n      return elem;\n    }\n  };\n}\n\nfunction newAttr(key, val) {\n  if (stackProps.length) {\n    stackProps[stackProps.length - 1][key] = val;\n  } else {\n    return attr(key, val);\n  }\n}\n\nfunction stackOpen(tname, key, statics, ...attrs) {\n  const props = { key, statics };\n  for (let a = 0; a < attrs.length; a += 2) {\n    props[attrs[a]] = attrs[a + 1];\n  }\n  stackChren.push([]);\n  stackProps.push(props);\n}\n\nfunction stackClose(tname) {\n  const chren = stackChren.pop();\n  const props = stackProps.pop();\n  return tname(props, () => chren.forEach(args => args[0](...args[1])));\n}\n\nfunction stackVoid(...args) {\n  stackOpen(...args);\n  return stackClose(args[0]);\n}\n\n// Patch element factories.\nconst newElementClose = wrapIdomFunc(elementClose, stackClose);\nconst newElementOpen = wrapIdomFunc(elementOpen, stackOpen);\nconst newElementOpenEnd = wrapIdomFunc(elementOpenEnd);\nconst newElementOpenStart = wrapIdomFunc(elementOpenStart, stackOpen);\nconst newElementVoid = wrapIdomFunc(elementVoid, stackVoid);\nconst newText = wrapIdomFunc(text);\n\n// Convenience function for declaring an Incremental DOM element using\n// hyperscript-style syntax.\nexport function element(tname, attrs, chren) {\n  const atype = typeof attrs;\n\n  // If attributes are a function, then they should be treated as children.\n  if (atype === 'function' || atype === 'string') {\n    chren = attrs;\n  }\n\n  // Ensure the attributes are an object.\n  if (atype !== 'object') {\n    attrs = {};\n  }\n\n  // We open the element so we can set attrs after.\n  newElementOpenStart(tname, attrs.key, attrs.statics);\n\n  // Delete so special attrs don't actually get set.\n  delete attrs.key;\n  delete attrs.statics;\n\n  // Set attributes.\n  Object.keys(attrs).forEach(name => newAttr(name, attrs[name]));\n\n  // Close before we render the descendant tree.\n  newElementOpenEnd(tname);\n\n  const ctype = typeof chren;\n  if (ctype === 'function') {\n    chren();\n  } else if (ctype === 'string' || ctype === 'number') {\n    newText(chren);\n  }\n\n  return newElementClose(tname);\n}\n\n// We don't have to do anything special for the text function; it's just a\n// straight export from Incremental DOM.\nexport {\n  newAttr as attr,\n  newElementClose as elementClose,\n  newElementOpen as elementOpen,\n  newElementOpenEnd as elementOpenEnd,\n  newElementOpenStart as elementOpenStart,\n  newElementVoid as elementVoid,\n  newText as text,\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/api/vdom.js\n **/","\n/**\n * @license\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n'use strict';\n\n/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * A cached reference to the hasOwnProperty function.\n */\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * A cached reference to the create function.\n */\nvar create = Object.create;\n\n/**\n * Used to prevent property collisions between our \"map\" and its prototype.\n * @param {!Object<string, *>} map The map to check.\n * @param {string} property The property to check.\n * @return {boolean} Whether map has property.\n */\nvar has = function (map, property) {\n  return hasOwnProperty.call(map, property);\n};\n\n/**\n * Creates an map object without a prototype.\n * @return {!Object}\n */\nvar createMap = function () {\n  return create(null);\n};\n\n/**\n * Keeps track of information needed to perform diffs for a given DOM node.\n * @param {!string} nodeName\n * @param {?string=} key\n * @constructor\n */\nfunction NodeData(nodeName, key) {\n  /**\n   * The attributes and their values.\n   * @const {!Object<string, *>}\n   */\n  this.attrs = createMap();\n\n  /**\n   * An array of attribute name/value pairs, used for quickly diffing the\n   * incomming attributes to see if the DOM node's attributes need to be\n   * updated.\n   * @const {Array<*>}\n   */\n  this.attrsArr = [];\n\n  /**\n   * The incoming attributes for this Node, before they are updated.\n   * @const {!Object<string, *>}\n   */\n  this.newAttrs = createMap();\n\n  /**\n   * The key used to identify this node, used to preserve DOM nodes when they\n   * move within their parent.\n   * @const\n   */\n  this.key = key;\n\n  /**\n   * Keeps track of children within this node by their key.\n   * {?Object<string, !Element>}\n   */\n  this.keyMap = null;\n\n  /**\n   * Whether or not the keyMap is currently valid.\n   * {boolean}\n   */\n  this.keyMapValid = true;\n\n  /**\n   * The node name for this node.\n   * @const {string}\n   */\n  this.nodeName = nodeName;\n\n  /**\n   * @type {?string}\n   */\n  this.text = null;\n}\n\n/**\n * Initializes a NodeData object for a Node.\n *\n * @param {Node} node The node to initialize data for.\n * @param {string} nodeName The node name of node.\n * @param {?string=} key The key that identifies the node.\n * @return {!NodeData} The newly initialized data object\n */\nvar initData = function (node, nodeName, key) {\n  var data = new NodeData(nodeName, key);\n  node['__incrementalDOMData'] = data;\n  return data;\n};\n\n/**\n * Retrieves the NodeData object for a Node, creating it if necessary.\n *\n * @param {Node} node The node to retrieve the data for.\n * @return {!NodeData} The NodeData for this Node.\n */\nvar getData = function (node) {\n  var data = node['__incrementalDOMData'];\n\n  if (!data) {\n    var nodeName = node.nodeName.toLowerCase();\n    var key = null;\n\n    if (node instanceof Element) {\n      key = node.getAttribute('key');\n    }\n\n    data = initData(node, nodeName, key);\n  }\n\n  return data;\n};\n\n/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/** @const */\nvar symbols = {\n  default: '__default',\n\n  placeholder: '__placeholder'\n};\n\n/**\n * @param {string} name\n * @return {string|undefined} The namespace to use for the attribute.\n */\nvar getNamespace = function (name) {\n  if (name.lastIndexOf('xml:', 0) === 0) {\n    return 'http://www.w3.org/XML/1998/namespace';\n  }\n\n  if (name.lastIndexOf('xlink:', 0) === 0) {\n    return 'http://www.w3.org/1999/xlink';\n  }\n};\n\n/**\n * Applies an attribute or property to a given Element. If the value is null\n * or undefined, it is removed from the Element. Otherwise, the value is set\n * as an attribute.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {?(boolean|number|string)=} value The attribute's value.\n */\nvar applyAttr = function (el, name, value) {\n  if (value == null) {\n    el.removeAttribute(name);\n  } else {\n    var attrNS = getNamespace(name);\n    if (attrNS) {\n      el.setAttributeNS(attrNS, name, value);\n    } else {\n      el.setAttribute(name, value);\n    }\n  }\n};\n\n/**\n * Applies a property to a given Element.\n * @param {!Element} el\n * @param {string} name The property's name.\n * @param {*} value The property's value.\n */\nvar applyProp = function (el, name, value) {\n  el[name] = value;\n};\n\n/**\n * Applies a style to an Element. No vendor prefix expansion is done for\n * property names/values.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {*} style The style to set. Either a string of css or an object\n *     containing property-value pairs.\n */\nvar applyStyle = function (el, name, style) {\n  if (typeof style === 'string') {\n    el.style.cssText = style;\n  } else {\n    el.style.cssText = '';\n    var elStyle = el.style;\n    var obj = /** @type {!Object<string,string>} */style;\n\n    for (var prop in obj) {\n      if (has(obj, prop)) {\n        elStyle[prop] = obj[prop];\n      }\n    }\n  }\n};\n\n/**\n * Updates a single attribute on an Element.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {*} value The attribute's value. If the value is an object or\n *     function it is set on the Element, otherwise, it is set as an HTML\n *     attribute.\n */\nvar applyAttributeTyped = function (el, name, value) {\n  var type = typeof value;\n\n  if (type === 'object' || type === 'function') {\n    applyProp(el, name, value);\n  } else {\n    applyAttr(el, name, /** @type {?(boolean|number|string)} */value);\n  }\n};\n\n/**\n * Calls the appropriate attribute mutator for this attribute.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {*} value The attribute's value.\n */\nvar updateAttribute = function (el, name, value) {\n  var data = getData(el);\n  var attrs = data.attrs;\n\n  if (attrs[name] === value) {\n    return;\n  }\n\n  var mutator = attributes[name] || attributes[symbols.default];\n  mutator(el, name, value);\n\n  attrs[name] = value;\n};\n\n/**\n * A publicly mutable object to provide custom mutators for attributes.\n * @const {!Object<string, function(!Element, string, *)>}\n */\nvar attributes = createMap();\n\n// Special generic mutator that's called for any attribute that does not\n// have a specific mutator.\nattributes[symbols.default] = applyAttributeTyped;\n\nattributes[symbols.placeholder] = function () {};\n\nattributes['style'] = applyStyle;\n\n/**\n * Gets the namespace to create an element (of a given tag) in.\n * @param {string} tag The tag to get the namespace for.\n * @param {?Node} parent\n * @return {?string} The namespace to create the tag in.\n */\nvar getNamespaceForTag = function (tag, parent) {\n  if (tag === 'svg') {\n    return 'http://www.w3.org/2000/svg';\n  }\n\n  if (getData(parent).nodeName === 'foreignObject') {\n    return null;\n  }\n\n  return parent.namespaceURI;\n};\n\n/**\n * Creates an Element.\n * @param {Document} doc The document with which to create the Element.\n * @param {?Node} parent\n * @param {string} tag The tag for the Element.\n * @param {?string=} key A key to identify the Element.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element.\n * @return {!Element}\n */\nvar createElement = function (doc, parent, tag, key, statics) {\n  var namespace = getNamespaceForTag(tag, parent);\n  var el = undefined;\n\n  if (namespace) {\n    el = doc.createElementNS(namespace, tag);\n  } else {\n    el = doc.createElement(tag);\n  }\n\n  initData(el, tag, key);\n\n  if (statics) {\n    for (var i = 0; i < statics.length; i += 2) {\n      updateAttribute(el, /** @type {!string}*/statics[i], statics[i + 1]);\n    }\n  }\n\n  return el;\n};\n\n/**\n * Creates a Text Node.\n * @param {Document} doc The document with which to create the Element.\n * @return {!Text}\n */\nvar createText = function (doc) {\n  var node = doc.createTextNode('');\n  initData(node, '#text', null);\n  return node;\n};\n\n/**\n * Creates a mapping that can be used to look up children using a key.\n * @param {?Node} el\n * @return {!Object<string, !Element>} A mapping of keys to the children of the\n *     Element.\n */\nvar createKeyMap = function (el) {\n  var map = createMap();\n  var child = el.firstElementChild;\n\n  while (child) {\n    var key = getData(child).key;\n\n    if (key) {\n      map[key] = child;\n    }\n\n    child = child.nextElementSibling;\n  }\n\n  return map;\n};\n\n/**\n * Retrieves the mapping of key to child node for a given Element, creating it\n * if necessary.\n * @param {?Node} el\n * @return {!Object<string, !Node>} A mapping of keys to child Elements\n */\nvar getKeyMap = function (el) {\n  var data = getData(el);\n\n  if (!data.keyMap) {\n    data.keyMap = createKeyMap(el);\n  }\n\n  return data.keyMap;\n};\n\n/**\n * Retrieves a child from the parent with the given key.\n * @param {?Node} parent\n * @param {?string=} key\n * @return {?Node} The child corresponding to the key.\n */\nvar getChild = function (parent, key) {\n  return key ? getKeyMap(parent)[key] : null;\n};\n\n/**\n * Registers an element as being a child. The parent will keep track of the\n * child using the key. The child can be retrieved using the same key using\n * getKeyMap. The provided key should be unique within the parent Element.\n * @param {?Node} parent The parent of child.\n * @param {string} key A key to identify the child with.\n * @param {!Node} child The child to register.\n */\nvar registerChild = function (parent, key, child) {\n  getKeyMap(parent)[key] = child;\n};\n\n/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/** @const */\nvar notifications = {\n  /**\n   * Called after patch has compleated with any Nodes that have been created\n   * and added to the DOM.\n   * @type {?function(Array<!Node>)}\n   */\n  nodesCreated: null,\n\n  /**\n   * Called after patch has compleated with any Nodes that have been removed\n   * from the DOM.\n   * Note it's an applications responsibility to handle any childNodes.\n   * @type {?function(Array<!Node>)}\n   */\n  nodesDeleted: null\n};\n\n/**\n * Keeps track of the state of a patch.\n * @constructor\n */\nfunction Context() {\n  /**\n   * @type {(Array<!Node>|undefined)}\n   */\n  this.created = notifications.nodesCreated && [];\n\n  /**\n   * @type {(Array<!Node>|undefined)}\n   */\n  this.deleted = notifications.nodesDeleted && [];\n}\n\n/**\n * @param {!Node} node\n */\nContext.prototype.markCreated = function (node) {\n  if (this.created) {\n    this.created.push(node);\n  }\n};\n\n/**\n * @param {!Node} node\n */\nContext.prototype.markDeleted = function (node) {\n  if (this.deleted) {\n    this.deleted.push(node);\n  }\n};\n\n/**\n * Notifies about nodes that were created during the patch opearation.\n */\nContext.prototype.notifyChanges = function () {\n  if (this.created && this.created.length > 0) {\n    notifications.nodesCreated(this.created);\n  }\n\n  if (this.deleted && this.deleted.length > 0) {\n    notifications.nodesDeleted(this.deleted);\n  }\n};\n\n/**\n* Makes sure that keyed Element matches the tag name provided.\n* @param {!string} nodeName The nodeName of the node that is being matched.\n* @param {string=} tag The tag name of the Element.\n* @param {?string=} key The key of the Element.\n*/\nvar assertKeyedTagMatches = function (nodeName, tag, key) {\n  if (nodeName !== tag) {\n    throw new Error('Was expecting node with key \"' + key + '\" to be a ' + tag + ', not a ' + nodeName + '.');\n  }\n};\n\n/** @type {?Context} */\nvar context = null;\n\n/** @type {?Node} */\nvar currentNode = null;\n\n/** @type {?Node} */\nvar currentParent = null;\n\n/** @type {?Element|?DocumentFragment} */\nvar root = null;\n\n/** @type {?Document} */\nvar doc = null;\n\n/**\n * Returns a patcher function that sets up and restores a patch context,\n * running the run function with the provided data.\n * @param {function((!Element|!DocumentFragment),!function(T),T=)} run\n * @return {function((!Element|!DocumentFragment),!function(T),T=)}\n * @template T\n */\nvar patchFactory = function (run) {\n  /**\n   * TODO(moz): These annotations won't be necessary once we switch to Closure\n   * Compiler's new type inference. Remove these once the switch is done.\n   *\n   * @param {(!Element|!DocumentFragment)} node\n   * @param {!function(T)} fn\n   * @param {T=} data\n   * @template T\n   */\n  var f = function (node, fn, data) {\n    var prevContext = context;\n    var prevRoot = root;\n    var prevDoc = doc;\n    var prevCurrentNode = currentNode;\n    var prevCurrentParent = currentParent;\n    var previousInAttributes = false;\n    var previousInSkip = false;\n\n    context = new Context();\n    root = node;\n    doc = node.ownerDocument;\n    currentParent = node.parentNode;\n\n    if ('production' !== 'production') {}\n\n    run(node, fn, data);\n\n    if ('production' !== 'production') {}\n\n    context.notifyChanges();\n\n    context = prevContext;\n    root = prevRoot;\n    doc = prevDoc;\n    currentNode = prevCurrentNode;\n    currentParent = prevCurrentParent;\n  };\n  return f;\n};\n\n/**\n * Patches the document starting at node with the provided function. This\n * function may be called during an existing patch operation.\n * @param {!Element|!DocumentFragment} node The Element or Document\n *     to patch.\n * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.\n *     calls that describe the DOM.\n * @param {T=} data An argument passed to fn to represent DOM state.\n * @template T\n */\nvar patchInner = patchFactory(function (node, fn, data) {\n  currentNode = node;\n\n  enterNode();\n  fn(data);\n  exitNode();\n\n  if ('production' !== 'production') {}\n});\n\n/**\n * Patches an Element with the the provided function. Exactly one top level\n * element call should be made corresponding to `node`.\n * @param {!Element} node The Element where the patch should start.\n * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.\n *     calls that describe the DOM. This should have at most one top level\n *     element call.\n * @param {T=} data An argument passed to fn to represent DOM state.\n * @template T\n */\nvar patchOuter = patchFactory(function (node, fn, data) {\n  currentNode = /** @type {!Element} */{ nextSibling: node };\n\n  fn(data);\n\n  if ('production' !== 'production') {}\n});\n\n/**\n * Checks whether or not the current node matches the specified nodeName and\n * key.\n *\n * @param {?string} nodeName The nodeName for this node.\n * @param {?string=} key An optional key that identifies a node.\n * @return {boolean} True if the node matches, false otherwise.\n */\nvar matches = function (nodeName, key) {\n  var data = getData(currentNode);\n\n  // Key check is done using double equals as we want to treat a null key the\n  // same as undefined. This should be okay as the only values allowed are\n  // strings, null and undefined so the == semantics are not too weird.\n  return nodeName === data.nodeName && key == data.key;\n};\n\n/**\n * Aligns the virtual Element definition with the actual DOM, moving the\n * corresponding DOM node to the correct location or creating it if necessary.\n * @param {string} nodeName For an Element, this should be a valid tag string.\n *     For a Text, this should be #text.\n * @param {?string=} key The key used to identify this element.\n * @param {?Array<*>=} statics For an Element, this should be an array of\n *     name-value pairs.\n */\nvar alignWithDOM = function (nodeName, key, statics) {\n  if (currentNode && matches(nodeName, key)) {\n    return;\n  }\n\n  var node = undefined;\n\n  // Check to see if the node has moved within the parent.\n  if (key) {\n    node = getChild(currentParent, key);\n    if (node && 'production' !== 'production') {\n      assertKeyedTagMatches(getData(node).nodeName, nodeName, key);\n    }\n  }\n\n  // Create the node if it doesn't exist.\n  if (!node) {\n    if (nodeName === '#text') {\n      node = createText(doc);\n    } else {\n      node = createElement(doc, currentParent, nodeName, key, statics);\n    }\n\n    if (key) {\n      registerChild(currentParent, key, node);\n    }\n\n    context.markCreated(node);\n  }\n\n  // If the node has a key, remove it from the DOM to prevent a large number\n  // of re-orders in the case that it moved far or was completely removed.\n  // Since we hold on to a reference through the keyMap, we can always add it\n  // back.\n  if (currentNode && getData(currentNode).key) {\n    currentParent.replaceChild(node, currentNode);\n    getData(currentParent).keyMapValid = false;\n  } else {\n    currentParent.insertBefore(node, currentNode);\n  }\n\n  currentNode = node;\n};\n\n/**\n * Clears out any unvisited Nodes, as the corresponding virtual element\n * functions were never called for them.\n */\nvar clearUnvisitedDOM = function () {\n  var node = currentParent;\n  var data = getData(node);\n  var keyMap = data.keyMap;\n  var keyMapValid = data.keyMapValid;\n  var child = node.lastChild;\n  var key = undefined;\n\n  if (child === currentNode && keyMapValid) {\n    return;\n  }\n\n  if (data.attrs[symbols.placeholder] && node !== root) {\n    if ('production' !== 'production') {}\n    return;\n  }\n\n  while (child !== currentNode) {\n    node.removeChild(child);\n    context.markDeleted( /** @type {!Node}*/child);\n\n    key = getData(child).key;\n    if (key) {\n      delete keyMap[key];\n    }\n    child = node.lastChild;\n  }\n\n  // Clean the keyMap, removing any unusued keys.\n  if (!keyMapValid) {\n    for (key in keyMap) {\n      child = keyMap[key];\n      if (child.parentNode !== node) {\n        context.markDeleted(child);\n        delete keyMap[key];\n      }\n    }\n\n    data.keyMapValid = true;\n  }\n};\n\n/**\n * Changes to the first child of the current node.\n */\nvar enterNode = function () {\n  currentParent = currentNode;\n  currentNode = null;\n};\n\n/**\n * Changes to the next sibling of the current node.\n */\nvar nextNode = function () {\n  if (currentNode) {\n    currentNode = currentNode.nextSibling;\n  } else {\n    currentNode = currentParent.firstChild;\n  }\n};\n\n/**\n * Changes to the parent of the current node, removing any unvisited children.\n */\nvar exitNode = function () {\n  clearUnvisitedDOM();\n\n  currentNode = currentParent;\n  currentParent = currentParent.parentNode;\n};\n\n/**\n * Makes sure that the current node is an Element with a matching tagName and\n * key.\n *\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @return {!Element} The corresponding Element.\n */\nvar coreElementOpen = function (tag, key, statics) {\n  nextNode();\n  alignWithDOM(tag, key, statics);\n  enterNode();\n  return (/** @type {!Element} */currentParent\n  );\n};\n\n/**\n * Closes the currently open Element, removing any unvisited children if\n * necessary.\n *\n * @return {!Element} The corresponding Element.\n */\nvar coreElementClose = function () {\n  if ('production' !== 'production') {}\n\n  exitNode();\n  return (/** @type {!Element} */currentNode\n  );\n};\n\n/**\n * Makes sure the current node is a Text node and creates a Text node if it is\n * not.\n *\n * @return {!Text} The corresponding Text Node.\n */\nvar coreText = function () {\n  nextNode();\n  alignWithDOM('#text', null, null);\n  return (/** @type {!Text} */currentNode\n  );\n};\n\n/**\n * Gets the current Element being patched.\n * @return {!Element}\n */\nvar currentElement = function () {\n  if ('production' !== 'production') {}\n  return (/** @type {!Element} */currentParent\n  );\n};\n\n/**\n * Skips the children in a subtree, allowing an Element to be closed without\n * clearing out the children.\n */\nvar skip = function () {\n  if ('production' !== 'production') {}\n  currentNode = currentParent.lastChild;\n};\n\n/**\n * The offset in the virtual element declaration where the attributes are\n * specified.\n * @const\n */\nvar ATTRIBUTES_OFFSET = 3;\n\n/**\n * Builds an array of arguments for use with elementOpenStart, attr and\n * elementOpenEnd.\n * @const {Array<*>}\n */\nvar argsBuilder = [];\n\n/**\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} const_args Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {!Element} The corresponding Element.\n */\nvar elementOpen = function (tag, key, statics, const_args) {\n  if ('production' !== 'production') {}\n\n  var node = coreElementOpen(tag, key, statics);\n  var data = getData(node);\n\n  /*\n   * Checks to see if one or more attributes have changed for a given Element.\n   * When no attributes have changed, this is much faster than checking each\n   * individual argument. When attributes have changed, the overhead of this is\n   * minimal.\n   */\n  var attrsArr = data.attrsArr;\n  var newAttrs = data.newAttrs;\n  var attrsChanged = false;\n  var i = ATTRIBUTES_OFFSET;\n  var j = 0;\n\n  for (; i < arguments.length; i += 1, j += 1) {\n    if (attrsArr[j] !== arguments[i]) {\n      attrsChanged = true;\n      break;\n    }\n  }\n\n  for (; i < arguments.length; i += 1, j += 1) {\n    attrsArr[j] = arguments[i];\n  }\n\n  if (j < attrsArr.length) {\n    attrsChanged = true;\n    attrsArr.length = j;\n  }\n\n  /*\n   * Actually perform the attribute update.\n   */\n  if (attrsChanged) {\n    for (i = ATTRIBUTES_OFFSET; i < arguments.length; i += 2) {\n      newAttrs[arguments[i]] = arguments[i + 1];\n    }\n\n    for (var _attr in newAttrs) {\n      updateAttribute(node, _attr, newAttrs[_attr]);\n      newAttrs[_attr] = undefined;\n    }\n  }\n\n  return node;\n};\n\n/**\n * Declares a virtual Element at the current location in the document. This\n * corresponds to an opening tag and a elementClose tag is required. This is\n * like elementOpen, but the attributes are defined using the attr function\n * rather than being passed as arguments. Must be folllowed by 0 or more calls\n * to attr, then a call to elementOpenEnd.\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n */\nvar elementOpenStart = function (tag, key, statics) {\n  if ('production' !== 'production') {}\n\n  argsBuilder[0] = tag;\n  argsBuilder[1] = key;\n  argsBuilder[2] = statics;\n};\n\n/***\n * Defines a virtual attribute at this point of the DOM. This is only valid\n * when called between elementOpenStart and elementOpenEnd.\n *\n * @param {string} name\n * @param {*} value\n */\nvar attr = function (name, value) {\n  if ('production' !== 'production') {}\n\n  argsBuilder.push(name, value);\n};\n\n/**\n * Closes an open tag started with elementOpenStart.\n * @return {!Element} The corresponding Element.\n */\nvar elementOpenEnd = function () {\n  if ('production' !== 'production') {}\n\n  var node = elementOpen.apply(null, argsBuilder);\n  argsBuilder.length = 0;\n  return node;\n};\n\n/**\n * Closes an open virtual Element.\n *\n * @param {string} tag The element's tag.\n * @return {!Element} The corresponding Element.\n */\nvar elementClose = function (tag) {\n  if ('production' !== 'production') {}\n\n  var node = coreElementClose();\n\n  if ('production' !== 'production') {}\n\n  return node;\n};\n\n/**\n * Declares a virtual Element at the current location in the document that has\n * no children.\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} const_args Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {!Element} The corresponding Element.\n */\nvar elementVoid = function (tag, key, statics, const_args) {\n  elementOpen.apply(null, arguments);\n  return elementClose(tag);\n};\n\n/**\n * Declares a virtual Element at the current location in the document that is a\n * placeholder element. Children of this Element can be manually managed and\n * will not be cleared by the library.\n *\n * A key must be specified to make sure that this node is correctly preserved\n * across all conditionals.\n *\n * @param {string} tag The element's tag.\n * @param {string} key The key used to identify this element.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} const_args Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {!Element} The corresponding Element.\n */\nvar elementPlaceholder = function (tag, key, statics, const_args) {\n  if ('production' !== 'production') {}\n\n  elementOpen.apply(null, arguments);\n  skip();\n  return elementClose(tag);\n};\n\n/**\n * Declares a virtual Text at this point in the document.\n *\n * @param {string|number|boolean} value The value of the Text.\n * @param {...(function((string|number|boolean)):string)} const_args\n *     Functions to format the value which are called only when the value has\n *     changed.\n * @return {!Text} The corresponding text node.\n */\nvar text = function (value, const_args) {\n  if ('production' !== 'production') {}\n\n  var node = coreText();\n  var data = getData(node);\n\n  if (data.text !== value) {\n    data.text = /** @type {string} */value;\n\n    var formatted = value;\n    for (var i = 1; i < arguments.length; i += 1) {\n      /*\n       * Call the formatter function directly to prevent leaking arguments.\n       * https://github.com/google/incremental-dom/pull/204#issuecomment-178223574\n       */\n      var fn = arguments[i];\n      formatted = fn(formatted);\n    }\n\n    node.data = formatted;\n  }\n\n  return node;\n};\n\nexports.patch = patchInner;\nexports.patchInner = patchInner;\nexports.patchOuter = patchOuter;\nexports.currentElement = currentElement;\nexports.skip = skip;\nexports.elementVoid = elementVoid;\nexports.elementOpenStart = elementOpenStart;\nexports.elementOpenEnd = elementOpenEnd;\nexports.elementOpen = elementOpen;\nexports.elementClose = elementClose;\nexports.elementPlaceholder = elementPlaceholder;\nexports.text = text;\nexports.attr = attr;\nexports.symbols = symbols;\nexports.attributes = attributes;\nexports.applyAttr = applyAttr;\nexports.applyProp = applyProp;\nexports.notifications = notifications;\n\n//# sourceMappingURL=incremental-dom-cjs.js.map\n\n\n/** WEBPACK FOOTER **\n ** ./~/incremental-dom/dist/incremental-dom-cjs.js\n **/","const doc = document;\nconst win = window;\nconst div = doc.createElement('div');\nexport const customElementsV0 = !!doc.registerElement;\nexport const customElementsV1 = !!win.customElements;\nexport const shadowDomV0 = !!div.createShadowRoot;\nexport const shadowDomV1 = !!div.attachShadow;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/util/support.js\n **/","import {\n  connected as $connected,\n  created as $created,\n  props as $props,\n  renderer as $renderer,\n  rendererDebounced as $rendererDebounced,\n} from '../util/symbols';\nimport { customElementsV0 } from '../util/support';\nimport data from '../util/data';\nimport debounce from '../util/debounce';\nimport getOwnPropertyDescriptors from '../util/get-own-property-descriptors';\n\nexport default class Component extends HTMLElement {\n  constructor() {\n    super();\n    this.createdCallback();\n  }\n\n  connectedCallback() {\n    const ctor = this.constructor;\n    const { attached } = ctor;\n    const render = ctor[$renderer];\n    this[$connected] = true;\n    if (typeof render === 'function') {\n      render(this);\n    }\n    if (typeof attached === 'function') {\n      attached(this);\n    }\n  }\n\n  disconnectedCallback() {\n    const { detached } = this.constructor;\n    this[$connected] = false;\n    if (typeof detached === 'function') {\n      detached(this);\n    }\n  }\n\n  attributeChangedCallback(name, oldValue, newValue) {\n    const { attributeChanged, observedAttributes } = this.constructor;\n    const propertyName = data(this, 'attributeLinks')[name];\n\n    // In V0 we have to ensure the attribute is being observed.\n    if (customElementsV0 && observedAttributes.indexOf(name) === -1) {\n      return;\n    }\n\n    if (propertyName) {\n      const propData = data(this, `api/property/${propertyName}`);\n\n      // This ensures a property set doesn't cause the attribute changed\n      // handler to run again once we set this flag. This only ever has a\n      // chance to run when you set an attribute, it then sets a property and\n      // then that causes the attribute to be set again.\n      if (propData.syncingAttribute) {\n        propData.syncingAttribute = false;\n      } else {\n        // Sync up the property.\n        const propOpts = this.constructor.props[propertyName];\n        propData.settingAttribute = true;\n        this[propertyName] = newValue !== null && propOpts.deserialize ? propOpts.deserialize(newValue) : newValue;\n      }\n    }\n\n    if (attributeChanged) {\n      attributeChanged(this, { name, newValue, oldValue });\n    }\n  }\n\n  createdCallback() {\n    const elemData = data(this);\n    const readyCallbacks = elemData.readyCallbacks;\n    const Ctor = this.constructor;\n    const { created, observedAttributes, props } = Ctor;\n\n    // Ensures that this can never be called twice.\n    if (this[$created]) return;\n    this[$created] = true;\n\n    // Set up a renderer that is debounced for property sets to call directly.\n    this[$rendererDebounced] = debounce(Ctor[$renderer]);\n\n    if (props) {\n      Ctor[$props](this);\n    }\n\n    if (created) {\n      created(this);\n    }\n\n    if (readyCallbacks) {\n      readyCallbacks.forEach(cb => cb(this));\n      delete elemData.readyCallbacks;\n    }\n\n    // In v0 we must ensure the attributeChangedCallback is called for attrs\n    // that aren't linked to props so that the callback behaves the same no\n    // matter if v0 or v1 is being used.\n    if (customElementsV0) {\n      observedAttributes.forEach(name => {\n        const propertyName = data(this, 'attributeLinks')[name];\n        if (!propertyName) {\n          this.attributeChangedCallback(name, null, this.getAttribute(name));\n        }\n      });\n    }\n  }\n\n  attachedCallback() {\n    this.connectedCallback();\n  }\n\n  detachedCallback() {\n    this.disconnectedCallback();\n  }\n\n  static get observedAttributes() {\n    return [];\n  }\n\n  static get props() {\n    return {};\n  }\n\n  static extend(definition = {}, Base = this) {\n    // Create class for the user.\n    class Ctor extends Base {}\n\n    // For inheriting from the object literal.\n    const opts = getOwnPropertyDescriptors(definition);\n    const prot = getOwnPropertyDescriptors(definition.prototype);\n\n    // Prototype is non configurable (but is writable) s\n    delete opts.prototype;\n\n    // Pass on static and instance members from the definition.\n    Object.defineProperties(Ctor, opts);\n    Object.defineProperties(Ctor.prototype, prot);\n\n    return Ctor;\n  }\n\n  // This is a default implementation that does strict equality copmarison on\n  // prevoius props and next props. It synchronously renders on the first prop\n  // that is different and returns immediately.\n  static updated(elem, prev) {\n    if (!prev) {\n      return true;\n    }\n\n    for (const name in prev) { // eslint-disable-line no-restricted-syntax\n      if (prev[name] !== elem[name]) {\n        return true;\n      }\n    }\n  }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/api/component.js\n **/","export default function (element, namespace = '') {\n  const data = element.__SKATE_DATA || (element.__SKATE_DATA = {});\n  return namespace && (data[namespace] || (data[namespace] = {})) || data;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/util/data.js\n **/","export default function (fn) {\n  let called = false;\n  return (...args) => {\n    if (!called) {\n      called = true;\n      setTimeout(() => {\n        called = false;\n        fn.apply(this, args);\n      });\n    }\n  };\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/util/debounce.js\n **/","export default function (obj) {\n  return Object.getOwnPropertyNames(obj || {}).reduce((prev, curr) => {\n    prev[curr] = Object.getOwnPropertyDescriptor(obj, curr);\n    return prev;\n  }, {});\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/util/get-own-property-descriptors.js\n **/","import {\n  name as $name,\n  props as $props,\n  renderer as $renderer,\n} from '../util/symbols';\nimport { customElementsV0, customElementsV1 } from '../util/support';\nimport Component from './component';\nimport createRenderer from '../lifecycle/render';\nimport dashCase from '../util/dash-case';\nimport initProps from '../lifecycle/props-init';\n\nconst registry = {};\n\n// Ensures that definitions passed as part of the constructor are functions\n// that return property definitions used on the element.\nfunction ensurePropertyFunctions(Ctor) {\n  const props = Ctor.props;\n  const names = Object.keys(props || {});\n  return names.reduce((descriptors, descriptorName) => {\n    descriptors[descriptorName] = props[descriptorName];\n    if (typeof descriptors[descriptorName] !== 'function') {\n      descriptors[descriptorName] = initProps(descriptors[descriptorName]);\n    }\n    return descriptors;\n  }, {});\n}\n\n// Ensures the property definitions are transformed to objects that can be used\n// to create properties on the element.\nfunction ensurePropertyDefinitions(Ctor) {\n  const props = ensurePropertyFunctions(Ctor);\n  return Object.keys(props).reduce((descriptors, descriptorName) => {\n    descriptors[descriptorName] = props[descriptorName](descriptorName);\n    return descriptors;\n  }, {});\n}\n\n// Ensures linked properties that have linked attributes are pre-formatted to\n// the attribute name in which they are linked.\nfunction formatLinkedAttributes(Ctor) {\n  const { observedAttributes, props } = Ctor;\n\n  if (!props) {\n    return;\n  }\n\n  Object.keys(props).forEach((name) => {\n    const prop = props[name];\n    const attr = prop.attribute;\n    if (attr) {\n      // Ensure the property is updated.\n      const linkedAttr = prop.attribute = attr === true ? dashCase(name) : attr;\n\n      // Automatically observe the attribute since they're linked from the\n      // attributeChangedCallback.\n      if (observedAttributes.indexOf(linkedAttr) === -1) {\n        observedAttributes.push(linkedAttr);\n      }\n    }\n  });\n\n  // Merge observed attributes.\n  Object.defineProperty(Ctor, 'observedAttributes', {\n    configurable: true,\n    enumerable: true,\n    get() {\n      return observedAttributes;\n    },\n  });\n}\n\nfunction createInitProps(Ctor) {\n  const props = ensurePropertyDefinitions(Ctor);\n\n  return (elem) => {\n    if (!props) {\n      return;\n    }\n\n    Object.keys(props).forEach((name) => {\n      const prop = props[name];\n      prop.created(elem);\n\n      // https://bugs.webkit.org/show_bug.cgi?id=49739\n      //\n      // When Webkit fixes that bug so that native property accessors can be\n      // retrieved, we can move defining the property to the prototype and away\n      // from having to do if for every instance as all other browsers support\n      // this.\n      Object.defineProperty(elem, name, prop);\n    });\n  };\n}\n\nfunction generateUniqueName(name) {\n  // we don't need to generate a unique name if it's the first time\n  if (!registry[name]) {\n    registry[name] = true;\n    return name;\n  }\n  // http://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript/2117523#2117523\n  const rand = 'xxxxxxxx'.replace(/[xy]/g, (c) => {\n    const r = Math.random() * 16 | 0;\n    const v = c === 'x' ? r : (r & 0x3 | 0x8);\n    return v.toString(16);\n  });\n\n  return `${name}-${rand}`;\n}\n\nexport default function (name, opts) {\n  if (opts === undefined) {\n    throw new Error(`You have to define options to register a component ${name}`);\n  }\n\n  const uniqueName = generateUniqueName(name);\n  const Ctor = typeof opts === 'object' ? Component.extend(opts) : opts;\n\n  formatLinkedAttributes(Ctor);\n\n  Ctor[$name] = uniqueName;\n  Ctor[$props] = createInitProps(Ctor);\n  Ctor[$renderer] = createRenderer(Ctor);\n\n  if (customElementsV1) {\n    window.customElements.define(uniqueName, Ctor, { extends: Ctor.extends });\n  } else if (customElementsV0) {\n    return document.registerElement(uniqueName, Ctor);\n  } else {\n    throw new Error('Skate requires native custom element support or a polyfill.');\n  }\n\n  return Ctor;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/api/define.js\n **/","import { patchInner } from 'incremental-dom';\nimport { connected as $connected, props as $props, rendering as $rendering, shadowRoot as $shadowRoot } from '../util/symbols';\nimport { shadowDomV0, shadowDomV1 } from '../util/support';\nimport props from '../api/props';\n\nexport default function (Ctor) {\n  const { render, rendered, updated } = Ctor;\n\n  return (elem) => {\n    if (elem[$rendering] || !elem[$connected]) {\n      return;\n    }\n\n    // Flag as rendering. This prevents anything from trying to render - or\n    // queueing a render - while there is a pending render.\n    elem[$rendering] = true;\n\n    // Call the updated() callback to see if we should render.\n    let shouldRender = true;\n    if (updated) {\n      const prev = elem[$props];\n      elem[$props] = props(elem);\n      shouldRender = updated(elem, prev);\n    }\n\n    // Even though this would ideally be checked in the updated() callback,\n    // it may not be, so we ensure that there is a point in proceeding.\n    if (!render) {\n      elem[$rendering] = false;\n      return;\n    }\n\n    // Try and get the current shadow root (will be setup if not).\n    let sr = elem[$shadowRoot];\n\n    // Setup the shadow root if it hasn't been setup yet.\n    if (!sr) {\n      if (shadowDomV1) {\n        sr = elem.attachShadow({ mode: 'open' });\n      } else if (shadowDomV0) {\n        sr = elem.createShadowRoot();\n      } else {\n        sr = elem;\n      }\n\n      elem[$shadowRoot] = sr;\n    }\n\n    if (shouldRender) {\n      patchInner(sr, render, elem);\n      if (rendered) {\n        rendered(elem);\n      }\n    }\n\n    elem[$rendering] = false;\n  };\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lifecycle/render.js\n **/","import { renderer as $renderer } from '../util/symbols';\nimport assign from '../util/assign';\n\nfunction get(elem) {\n  const props = {};\n  Object.keys(elem.constructor.props).forEach((key) => {\n    props[key] = elem[key];\n  });\n\n  return props;\n}\n\nfunction set(elem, newProps) {\n  assign(elem, newProps);\n  if (elem.constructor.render) {\n    elem.constructor[$renderer](elem);\n  }\n}\n\nexport default function (elem, newProps) {\n  return typeof newProps === 'undefined' ? get(elem) : set(elem, newProps);\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/api/props.js\n **/","export default function (str) {\n  return str.split(/([A-Z])/).reduce((one, two, idx) => {\n    const dash = !one || idx % 2 === 0 ? '' : '-';\n    return `${one}${dash}${two.toLowerCase()}`;\n  });\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/util/dash-case.js\n **/","import {\n  rendererDebounced as $rendererDebounced,\n  rendering as $rendering,\n} from '../util/symbols';\nimport assign from '../util/assign';\nimport data from '../util/data';\nimport empty from '../util/empty';\n\nfunction getDefaultValue(elem, name, opts) {\n  return typeof opts.default === 'function' ? opts.default(elem, { name }) : opts.default;\n}\n\nfunction getInitialValue(elem, name, opts) {\n  return typeof opts.initial === 'function' ? opts.initial(elem, { name }) : opts.initial;\n}\n\nfunction createNativePropertyDefinition(name, opts) {\n  const prop = {\n    configurable: true,\n    enumerable: true,\n  };\n\n  prop.created = function (elem) { // eslint-disable-line func-names\n    const propData = data(elem, `api/property/${name}`);\n    const attributeName = opts.attribute;\n    let initialValue = elem[name];\n    let shouldSyncAttribute = false;\n\n    // Store property to attribute link information.\n    data(elem, 'attributeLinks')[attributeName] = name;\n    data(elem, 'propertyLinks')[name] = attributeName;\n\n    // Set up initial value if it wasn't specified.\n    if (empty(initialValue)) {\n      if (attributeName && elem.hasAttribute(attributeName)) {\n        initialValue = opts.deserialize(elem.getAttribute(attributeName));\n      } else if ('initial' in opts) {\n        initialValue = getInitialValue(elem, name, opts);\n        shouldSyncAttribute = true;\n      } else if ('default' in opts) {\n        initialValue = getDefaultValue(elem, name, opts);\n      }\n    }\n\n    if (shouldSyncAttribute) {\n      prop.set.call(elem, initialValue);\n    } else {\n      propData.internalValue = opts.coerce ? opts.coerce(initialValue) : initialValue;\n    }\n  };\n\n  prop.get = function () { // eslint-disable-line func-names\n    const propData = data(this, `api/property/${name}`);\n    const { internalValue } = propData;\n    if (typeof opts.get === 'function') {\n      return opts.get(this, { name, internalValue });\n    }\n    return internalValue;\n  };\n\n  prop.set = function (newValue) { // eslint-disable-line func-names\n    const propData = data(this, `api/property/${name}`);\n    let { oldValue } = propData;\n    let shouldRemoveAttribute = false;\n\n    if (empty(oldValue)) {\n      oldValue = null;\n    }\n\n    if (empty(newValue)) {\n      newValue = getDefaultValue(this, name, opts);\n      shouldRemoveAttribute = true;\n    }\n\n    if (typeof opts.coerce === 'function') {\n      newValue = opts.coerce(newValue);\n    }\n\n    propData.internalValue = newValue;\n\n    const changeData = { name, newValue, oldValue };\n\n    if (typeof opts.set === 'function') {\n      opts.set(this, changeData);\n    }\n\n    // Queue a re-render only if it's not currently rendering.\n    if (!this[$rendering]) {\n      this[$rendererDebounced](this);\n    }\n\n    propData.oldValue = newValue;\n\n    // Link up the attribute.\n    const attributeName = data(this, 'propertyLinks')[name];\n    if (attributeName && !propData.settingAttribute) {\n      const serializedValue = opts.serialize(newValue);\n      propData.syncingAttribute = true;\n      if (shouldRemoveAttribute || empty(serializedValue)) {\n        this.removeAttribute(attributeName);\n      } else {\n        this.setAttribute(attributeName, serializedValue);\n      }\n    }\n\n    // Allow the attribute to be linked again.\n    propData.settingAttribute = false;\n  };\n\n  return prop;\n}\n\nexport default function (opts) {\n  opts = opts || {};\n\n  if (typeof opts === 'function') {\n    opts = { coerce: opts };\n  }\n\n  return (name) => createNativePropertyDefinition(name, assign({\n    default: null,\n    deserialize: value => value,\n    serialize: value => value,\n  }, opts));\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lifecycle/props-init.js\n **/","const CustomEvent = ((Event) => {\n  if (Event) {\n    try {\n      new Event(); // eslint-disable-line no-new\n    } catch (e) {\n      return undefined;\n    }\n  }\n  return Event;\n})(window.CustomEvent);\n\nfunction createCustomEvent(name, opts = {}) {\n  if (CustomEvent) {\n    return new CustomEvent(name, opts);\n  }\n  const e = document.createEvent('CustomEvent');\n  e.initCustomEvent(name, opts.bubbles, opts.cancelable, opts.detail);\n  return e;\n}\n\nexport default function (elem, name, opts = {}) {\n  if (opts.bubbles === undefined) {\n    opts.bubbles = true;\n  }\n  if (opts.cancelable === undefined) {\n    opts.cancelable = true;\n  }\n  return elem.disabled ? true : elem.dispatchEvent(createCustomEvent(name, opts));\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/api/emit.js\n **/","import props from './props';\n\nfunction getValue(elem) {\n  const type = elem.type;\n  if (type === 'checkbox' || type === 'radio') {\n    return elem.checked ? elem.value || true : false;\n  }\n  return elem.value;\n}\n\nexport default function (elem, target) {\n  return (e) => {\n    const value = getValue(e.target);\n    const localTarget = target || e.target.name || 'value';\n\n    if (localTarget.indexOf('.') > -1) {\n      const parts = localTarget.split('.');\n      const firstPart = parts[0];\n      const propName = parts.pop();\n      const obj = parts.reduce((prev, curr) => (prev && prev[curr]), elem);\n\n      obj[propName || e.target.name] = value;\n      props(elem, {\n        [firstPart]: elem[firstPart],\n      });\n    } else {\n      props(elem, {\n        [localTarget]: value,\n      });\n    }\n  };\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/api/link.js\n **/","import { created as $created } from '../util/symbols';\nimport data from '../util/data';\n\nexport default function (elem, done) {\n  const info = data(elem);\n  if (elem[$created]) {\n    done(elem);\n  } else if (info.readyCallbacks) {\n    info.readyCallbacks.push(done);\n  } else {\n    info.readyCallbacks = [done];\n  }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/api/ready.js\n **/"],"sourceRoot":""}